Transcript




close interactive script
Click one of the buttons to take you to that part of the video.
1. Development Lifecycle
00:04
In this lesson, we'll look at how to apply
00:06
security concepts to software development.
00:09
Even though you may not be a software
00:10
developer yourself, most security professionals
00:13
work with software engineers in some capacity.
00:16
Just like other company resources, the applications
00:19
they develop need to be properly secured.
00:22
Today, we'll look at the two most common
00:24
development lifecycles to understand how you can
00:27
secure each step throughout the development process.
2. Waterfall Software Development Cycle Model
00:31
The most widely used development
00:32
model is the Waterfall model.
00:35
It's called this because each step is
00:36
completed before the next step is begun.
00:39
Each step flows to the next like a waterfall.
00:43
The first step in a Waterfall model is Requirements.
00:46
All requirements for the application need to be
00:49
gathered from the client, user, or stakeholder.
00:52
The next step is Design.
00:54
This is when the software is
00:56
documented, diagrammed, and designed.
00:59
After that, we have Implementation.
01:01
This is the actual coding and building of the application.
01:04
We then have the Testing phase.
01:07
During this phase, a quality assurance team makes
01:10
sure that the team met the requirements, that the
01:12
code works properly across devices, and that
01:15
security flaws and vulnerabilities were phased out.
01:19
After Testing comes the Deployment.
01:21
This is when the application is
01:23
released to a client or to the public.
01:26
The final step is Maintenance.
01:28
The application is in use in this phase, but it's
01:31
monitored for bugs or problems that are quickly patched.
01:34
This is an ongoing stage that
01:36
continues throughout the app's life.
01:39
Understand that the application will likely go through
01:42
some of these steps multiple times before moving on.
01:45
For example, the application might go through
01:48
the Design step five times before it's ready
01:50
to move on to the Implementation step.
01:53
Then the application may move from the Implementation stage
01:56
back to the Design stage if a new feature needs to be added.
02:00
This entire development cycle is a slow process
02:03
and may take months or years to complete.
02:06
The Waterfall method lacks flexibility
02:09
since the requirements determined in the
02:10
beginning carry through to the end product.
3. Agile Model
02:14
A more agile approach was introduced in 2001
02:17
which approaches software development as a
02:20
continuous, changing process with never-ending
02:22
versions, bug fixes, and enhancements.
02:25
This approach is aptly named Agile.
02:29
One reason the Agile methodology is pragmatic
02:32
is because security vulnerabilities are
02:34
constantly addressed with new updates and fixes.
4. Agile Model
02:37
Unlike Waterfall, Agile doesn't work
02:40
on the entire application at once.
02:42
Instead, it breaks development into
02:44
smaller time frames called Sprints.
02:46
Each Sprint has a specific duration,
02:49
usually two to three weeks.
02:51
Within this time frame, developers
02:53
work on a specific application feature.
02:55
These features typically go through the same stages
02:59
that all applications go through, such as Requirements,
03:01
Design, Development, Testing, and Deployment.
03:05
At the end of the Sprint, the
03:06
developers move on to the next feature.
03:09
With Agile, you perform testing throughout the development
03:12
cycle to help catch security vulnerabilities early.
03:15
Waterfall, on the other hand, leaves
03:17
testing until the end of the cycle.
03:19
This can cause testing time to
03:21
be cut short to meet deadlines.
5. Coding Errors
03:23
Coding errors and design flaws are the
03:26
main causes of software vulnerabilities.
03:28
We can categorize these errors into two
03:30
types: compile errors and runtime errors.
03:34
A compile error refers to an error that occurs
03:37
during the building or compilation stage.
03:39
The error compromises the software implementation,
03:42
which prevents it from running at all.
03:45
A runtime refers to an error that
03:47
occurs while the software is running.
03:49
The software begins execution, but it fails
03:52
when it cannot resolve a problem it encounters.
03:55
During the coding and design phases, you can
03:57
increase application security by integrating
04:00
security testing into each step of the process.
04:03
Let's look at three testing methods: static, dynamic,
04:06
and interactive application security testing.
6. Static Application Security Testing
04:09
Static application security testing, or
04:11
SAST, is also known as white box testing.
04:15
SAST focuses on analyzing source code, binaries,
04:20
and byte code early in the development process.
04:23
SAST tools are good at identifying things like
04:26
SQL-injection vulnerabilities and buffer overflows.
04:30
They can identify the exact cause of a coding
04:33
problem, but only in code not yet deployed.
04:36
They're language specific, but you can run
04:38
them continually and apply them widely.
04:41
Please note that they do have a high percent
04:44
of false positives and are limited in the
04:46
types of vulnerabilities they can detect.
7. Dynamic Application Security Testing
04:49
Dynamic application security testing, or
04:51
DAST, is also known as black box testing.
04:54
DAST scans a deployed application once it enters runtime.
04:59
The results are based on how the application
05:01
responds to a series of tests from the outside.
05:05
These tests aren't language specific and
05:07
have a lower rate of false positives.
05:10
The downsides to DASTs are that they're hard
05:12
to automate, can't pinpoint the exact cause of
05:15
a flaw, and can take up to a week to complete.
8. Interactive Application Security Testing
05:19
Finally, we have interactive application
05:21
security testing, or IAST, which can be broken
05:24
down into two types: passive and active.
05:26
In passive IAST, we build interactivity
05:30
into static application security testing.
05:34
IAST tools are source code
05:35
scanners that work during runtime.
05:36
In active IAST, the testing tools can access interpreters
05:41
and compliers, allowing precise identification of a
05:45
problematic line of code during runtime.
05:47
This speeds up the testing and remediation process.
05:51
The combination of passive and active IAST can help us in
05:54
the development stage by catching vulnerabilities early,
05:58
in the QA stage by adding automated security checkpoints,
06:01
and in the production stage through continuous monitoring.
9. Summary
06:06
That's it for this lesson.
06:08
In this lesson, we reviewed two common software
06:10
development lifecycles: Waterfall and Agile.
06:13
Then we looked at two different kinds of coding
06:16
errors: compile errors and runtime errors.
06:20
We finished up by looking at static, dynamic,
06:22
and interactive application security testing and
06:26
how these tools can help us secure applications
06:28
throughout the development lifecycle.