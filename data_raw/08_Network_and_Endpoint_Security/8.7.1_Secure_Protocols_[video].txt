Transcript




close interactive script
Click one of the buttons to take you to that part of the video.
1. Secure Protocols
00:04
Let's spend a few minutes talking
00:06
about cryptographic protocols.
00:07
We're first going to look at Secure Sockets Layer, or SSL.
00:11
Then we'll discuss its newer version,
00:13
Transport Layer Security, or TLS.<br>
2. Secure HTTPS
00:16
Both SSL and TLS are cryptographic protocols
00:20
that provide security for TCP/IP communications.
00:23
Many application protocols use SSL
00:26
specifically for secure communications.
00:28
But both can be used to secure HTTP,
00:31
which is the protocol meant for requesting
00:33
and transmitting files over the internet.
00:36
The problem is that HTTP sends data in cleartext,
00:40
and these transmissions need to be secure.<br>
00:43
Let's say you want to buy a book
00:45
online from an e-commerce website.
00:47
You send them some type of payment information,
00:49
which is most likely a credit card number.
00:52
If you use HTTP, your credit card number, name, and
00:56
address are all broadcast as cleartext over the internet.
01:00
This information is all an identity thief needs to steal
01:03
your identity as well as the contents of your bank account.<br>
01:07
Using SSL or TLS, you can encrypt the HTTP
01:11
communications so that they're indecipherable
01:14
to anyone who doesn't have the decryption keys.<br>
3. Secure LDAP
01:17
SSL and TLS can provide encryption for Lightweight Directory
01:21
Access Protocol, or LDAP, and File Transfer Protocol, or FTP.
01:27
LDAP is a protocol used to access directories from
01:29
services which store sensitive authentication information
01:33
like Active Directory, eDirectory, and OpenLDAP.
01:37
This information is transmitted over a network in
01:39
cleartext unless an encryption protocol is applied.
01:43
Likewise, FTP needs a protocol like SSL or TLS
01:47
to encrypt FTP communications or your files and
01:50
authentication is sent in cleartext as well.<br>
01:54
An SSL or TLS session typically has
01:57
a server system and a client system.<br>
4. Certificates
02:00
To use SSL or TLS, you encrypt the
02:03
communications in that session.
02:05
The server must have a certificate
02:07
issued by an e-certificate authority.
02:09
It could be issued by trusted certificate
02:11
authorities such as Ntrust, or it could be minted
02:15
by your own in-house certificate authority.<br>
02:17
Either way, you're encrypting the communications
02:20
between the client and the server using SSL or TLS.
02:24
The use of a certificate issued by an e-certificate
02:27
authority indicates asymmetric encryption and the use
02:31
of public keys between the client and the server.<br>
5. SSL and TLS Versions
02:35
It's important to understand that TLS is a successor to SSL.
02:39
It was designed to be more secure,
02:41
though not backwards compatible with SSL.
02:45
TLS is an application-independent encryption mechanism.
02:49
In other words, the application that needs the encryption
02:52
decides the best way to initiate the TLS handshake process.
02:56
Also, TLS uses Diffie-Hellman to establish
02:59
the session key, which the client and
03:01
server use for the duration of the session.<br>
03:04
This process of establishing an SSL
03:06
tunnel is known as the SSL handshake.<br>
6. SSL/TLS
03:09
An SSL or TLS session begins when a client
03:14
initiates a secure connection with the server.
03:17
The client sends a special message to
03:19
the server called a client hello message.
03:22
The client hello message specifies the highest
03:25
SSL or TLS protocol version that it supports.
03:29
It also contains a random number, a list of
03:32
suggested ciphers, and compression methods.
03:35
When the server receives the client hello message,
03:37
it responds with a message called a server hello.
03:41
The server hello message contains the chosen
03:43
protocol version, another random number, a selected
03:47
cipher, and a selected compression method.
03:50
All these are chosen from the list that was
03:52
offered initially by the client hello message.<br>
03:55
The chosen protocol version is the
03:57
highest common version that both support.
04:00
For example, if the client supports TLS 1.0 and the
04:04
server supports TLS 1.2, they settle on TLS 1.0.
04:09
The server then sends a message to the
04:11
client called the certificate message.
04:13
Then the server sends another message to the client
04:16
called the server hello done message which indicates
04:19
that the server is done with the negotiation phase.
04:22
Once the client knows that the server is done,
04:25
it responds with a client key exchange message.<br>
04:29
Both the client and server use the random number
04:32
that they sent each other to compute a common
04:34
secret, which is called the master secret.
04:37
At this point, all other data for the
04:39
connection is derived from the master secret.
04:42
The client sends a changed cipher spec message that
04:45
says to the server, Everything that I'm going to
04:48
be sending you from now on will be encrypted.ï¿½<br>
04:50
After that, the client informs the server that
04:53
it's done by sending it a finished message.
04:56
The finished message contains some
04:58
important information like a hash and MAC.
05:01
The server receives the hash and MAC and attempts
05:04
to decrypt this finished message and verify it.
05:07
If it fails to decrypt the message, the handshake is
05:10
considered to have failed and the connection is ended.<br>
05:13
But, if it is able to decrypt the message and
05:16
verify the hash and MAC, the server responds to
05:19
the client with a change cipher spec message.
05:22
This says to the client, Everything coming from me will
05:25
now be encrypted. The server then sends a finished message.
05:29
Just as the finished message from the client had a hash and
05:32
MAC, the finished message from the server also contains both.
05:36
If they pass verification from the server, the
05:39
SSL or TLS handshake is considered to be complete.<br>
7. DNS Security
05:43
Another often overlooked vulnerability is DNS security.
05:47
DNS is like a phone book for the internet.
05:49
It takes names that people can remember and
05:52
converts them to IP addresses that couldn't
05:54
conceivably be memorized by humans.
05:57
The problem is that DNS queries and responses
05:59
are transmitted in cleartext by default.
06:02
This means that anyone could intercept the information
06:05
during transmission, including someone with malintent.<br>
06:09
For example, a hacker could send false information to
06:12
a DNS server with the knowledge that the server will
06:15
cache it to make for faster connections in the future.
06:19
When this happens, the server is considered poisoned.
06:22
Once poisoned, it may direct traffic to the
06:25
attacker's website, which can be made to look like
06:27
the site the user was trying to reach originally.
06:30
So, the user is unaware that he or she is on a
06:34
dangerous website and may share sensitive information.<br>
8. DNS Protection
06:37
To protect against this risk, you may employ a
06:40
standard of encryption called DNS over TLS, or DoT.
06:44
DoT encrypts DNS queries through the TLS
06:48
protocol by adding an encryption layer to TCP.<br>
06:52
An alternate approach is to
06:53
implement DNS over HTTPS, or DoH.
06:57
With this approach, both the queries
06:59
and the responses are encrypted.
07:02
DoH adds security by having the traffic flow integrated
07:05
with HTTP or HTTP/2 traffic instead of through UDP.
07:10
In this way, the queries and responses are meshed with
07:13
regular internet traffic flow, making it difficult for
07:17
an attacker to single out requests and responses.<br>
9. Summary
07:20
That's it for this lesson.
07:22
In this lesson, we talked about the roles of SSL and TLS.
07:26
We broke down how SSL handshakes work and took
07:29
a closer look at some specifics regarding TLS.
07:32
We finished with how TLS can help secure your
07:35
DNS server with DNS over TLS and DNS over HTTPS.<br>