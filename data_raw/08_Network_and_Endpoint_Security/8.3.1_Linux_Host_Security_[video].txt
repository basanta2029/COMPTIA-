
Transcript




close interactive script
Click one of the buttons to take you to that part of the video.
1. Linux Host Security
00:04
The Linux operating system is widely used
00:06
and preferred in the security community.
00:09
Just like its Windows counterpart,
00:11
though, Linux is vulnerable to attacks.
00:14
By default, the Linux OS is designed to reduce
00:17
vulnerability and attack surface, but attackers
00:20
are still able to exploit known vulnerabilities.
00:24
There's only one way to eliminate all potential
00:26
threats and that's to disconnect from the internet.
00:29
Unfortunately, this isn't an option for most users.
00:32
With that in mind, you should remain vigilant and
00:35
take the necessary precautions to protect your system.
00:39
In this lesson, we'll discuss how to minimize your
00:41
Linux system's attack surface with simple yet effective
00:44
methods for reducing the chances of an attack.
2. Unload Unnecessary Services
00:47
The first step is to lessen your
00:49
system's attack surface as a whole.
00:52
The more services that are loaded and active on a
00:55
system, the more opportunities exist for attack.
00:58
Many services utilize a specific TCP/IP
01:02
port that's exposed to the network.
01:04
Services such as DNS, FTP, SNMP, and others
01:09
may or may not be required on your system.
01:12
If not, these services should be unloaded and deactivated.
01:17
Different Linux distributions load various
01:20
programs and daemons, and certain programs and
01:23
daemons are necessary dependencies of others.
01:27
So make sure you understand your system's requirements
01:29
before you attempt to unload and deactivate anything.
01:33
To see a list of all loaded and active services,
01:36
you can use the ‘systemctl' command, as shown here.
01:41
When used, both the service name
01:44
and description are displayed.
01:46
Additionally, you can add the ‘list-dependencies'
01:47
statement to display a dependency services tree.
01:52
With this information, you can discover
01:54
potentially unneeded services and unload them.
01:57
You first stop the service and then
01:59
disable it from starting automatically.
02:01
A word of caution—do your research!
02:04
Don't simply unload a service
02:06
without knowing what it's used for.
02:08
It may be a system service or a
02:09
service that something else depends on.
02:12
Look up the name in a search engine, or use the ‘man'
02:15
or ‘info' utilities to find out what it's used for.
02:19
Only then, if you determine it's unneeded,
02:22
should you stop and disable the service.
3. Use Nmap
02:24
It may be necessary to have ports open
02:26
for a Linux system to work properly.
02:29
For example, if a server provides DHCP or
02:33
DNS services or web content, TCP/IP ports
02:37
must be open to allow everything to work.
02:40
One way to discover open ports on a
02:42
system is to use the Nmap utility.
02:44
Nmap is a tool that's either bundled with Linux
02:48
distributions or can be installed using apt or yum.
02:52
When used appropriately, this tool can provide you with
02:55
very useful information about a given system or network.
02:58
When used inappropriately, attackers can
03:00
take control and perform reconnaissance.
03:03
For our purposes, we can use Nmap
03:05
to show us our system's open ports.
03:09
Often, open ports are indications that a service
03:11
is running on the system that controls that port.
03:14
If we see a port open that shouldn't be,
03:16
it can tell us that a service is running
03:19
on the system that we probably don't need.
03:21
We can check the system and stop
03:23
and disable the service if needed.
4. Use Nmap
03:25
In the example here, Nmap shows
03:27
the default gateway's open ports.
03:30
There may be ports we expect and others we don't.
03:33
For example, here we see that port
03:35
80 is open with the service http.
03:38
If this machine doesn't require web services, we may
03:41
want to close that port by stopping the web server.
03:44
If we see an unexpected open port, we need to
03:47
find the service that's opening that port to
03:49
determine whether the service is necessary or not.
03:52
If it isn't, we can stop and disable
03:54
the service to close the port.
03:56
Just use this tool with caution.
03:58
Since Nmap is widely used by hackers,
04:01
running it may trigger alarms and alerts.
04:04
There are many command line parameters available with
04:07
Nmap that let us customize the desired command output.
04:11
Let's discuss a few.
04:12
The ‘–sU' and ‘–sT' parameters
04:19
display only UDP and TCP ports.
04:23
Keep in mind that these parameters might make
04:25
your scan take an extraordinarily long time.
04:29
Use ‘-6' to choose IPv6 scanning.
04:34
To enable OS detection, use ‘-A' or
04:38
‘–O'.
04:40
We use the ‘-p' parameter to specify a range, while the
04:44
‘-sn' parameter enables a ping-only scan to determine if
04:50
a host is up without having to perform a port scan.
5. Use Netstat
04:54
Netstat is another Linux or Windows tool
04:58
that we can use to scan for open ports.
05:00
In this example, a Linux machine was used
05:03
to display open ports on a system with IPv4.
05:07
I used the ‘–l' option to view a list of
05:10
listening sockets and the ‘4' option to
05:13
show only IPv4 addresses on the Linux host.
05:17
Here you see I have a socket open for ssh.
05:21
Also, the system is running NTP.
05:23
These are TCP/IP ports that are well
05:27
known as ports 22 and 123, respectively.
05:31
By using this output, I can also see
05:33
what else is running on the system.
05:36
We can customize the Netstat utility to provide us with
05:39
only the information we're specifically looking for.
05:42
As with Nmap, the Netstat utility
05:45
has several command line parameters.
05:47
For example:
05:48
‘-a' lists all listening and non-listening sockets.
05:52
‘-I' displays statistics for all your network interfaces.
05:58
‘-l' displays just listening sockets
06:02
or sockets that are open for listening.
06:06
‘-s' displays summary information for
06:09
each protocol enabled on the system.
06:13
‘-r' shows your routing table.
06:16
Keep in mind that these options may vary in
06:18
availability depending on whether we're using the
06:21
Linux version of Netstat or the Windows version.
6. Install Updates
06:24
In addition to unloading unneeded services, you also need
06:28
to make sure that your Linux operating system remains
06:31
current by installing operating system and program updates.
06:34
For example, as software is released, it's
06:37
usually not perfect and free of defects.
06:40
Defects can take the form of logic errors in which a
06:43
program doesn't calculate or apply input correctly.
06:46
There could be something wrong
06:48
with a screen display as well.
06:50
In addition, vulnerabilities can be introduced that
06:53
would allow threat actors to compromise your system.
06:57
Often, these defects are found only
06:59
after software has been released.
07:02
So once the software is in use and the defects
07:04
are found and corrected, it's important that
07:06
you update your software immediately.
07:09
You can manually update the packages on your
07:11
system using package managers such as yum or apt.
07:15
The one you use will depend on
07:17
which distribution you're using.
07:19
These processes scour the repository and
07:21
search for newer updates and patches.
07:24
If a single package requires an update, the package name can
07:27
be specified to check if that package requires an update.
07:31
Most often, though, it's a good practice
07:33
to update all available package updates.
07:35
For example, if you're running a Red Hat
07:38
variant, such as CentOS or Fedora, run
07:42
the ‘yum update' command, as shown here.
07:44
In this example, you see that only a
07:46
single package—libexif—needs an update.
07:51
When you use a Debian variant like Ubuntu or
07:54
Mint, you first run the ‘apt update' command.
07:57
This refreshes the repository information.
08:00
After that, you run ‘apt upgrade' to
08:03
perform the manual update process.
08:05
Notice that in this case, there
08:07
are 28 packages to be upgraded.
08:09
An exception to utilizing apt or yum is with SuSE Linux.
08:12
SuSE Linux uses a different package manager called zypper.
08:17
The syntax for the command is similar to
08:20
apt and yum and accomplishes the same tasks.
7. Enable a Host Firewall
08:23
The last topic for enabling Linux host security is to ensure
08:27
a host-based firewall is running on your Linux system.
08:30
One philosophy of computer security
08:32
is to utilize a layered approach.
08:35
Most systems are protected first by a network firewall.
08:38
If anything does happen to get through, threat actors also
08:42
have to contend with the host system's firewall as well.
08:45
Most, if not all, Linux systems are
08:48
distributed with host-firewall software.
08:51
This software is known as firewalld.
08:55
In some instances, there might even be a series of firewalls
08:57
that are specific to protecting certain network aspects.
09:01
These together form a solid barrier to attackers.
09:04
But nothing is foolproof and adding another
09:06
layer of protection is always a good idea.
09:09
The Linux host-based firewall adds additional
09:11
protection from outside entities, and it can also
09:14
protect the system from insider threats, too.
09:16
A host-based firewall acts like a gatekeeper between
09:20
your system and the external and internal network.
09:23
This firewall monitors all traffic that flows in
09:25
both directions between the computer and network.
09:28
You configure this firewall with a list of
09:30
rules called access control lists, or ACLs.
09:34
These rules define what is and
09:36
isn't allowed to pass through.
09:38
Several Linux distributions use the firewalld
09:41
daemon to implement host-based firewalls.
09:45
Other distributions might use a different package, so
09:48
check your distribution vendor to see which one to use.
09:52
First, make sure firewalld has
09:54
been installed on your system.
09:56
You can use the ‘yum' or ‘apt' command lines
09:59
to check whether it has, as shown here.
10:02
If those commands return a value, you know firewalld
10:05
has been installed and you can begin configuring it.
10:08
If you get a blank message or one stating firewalld could
10:11
not be found, you'll need to download and install it.
10:15
This can also be done using the ‘yum' or ‘apt' commands.
10:19
Know that firewalld depends on
10:21
the Python programming language.
10:23
If not already installed, just note that the installer will
10:26
also install the needed Python dependencies on your system.
10:31
If firewalld is already installed or if you just
10:33
installed it, you need to ensure it's running and
10:36
active with the ‘systemctl' command shown here.
10:40
It might not be running, and you might
10:42
see inactive or dead as the status.
10:45
If that's the case, you can start the daemon by
10:47
issuing the ‘systemctl start firewalld' command.
10:52
Checking the status again should show the daemon running.
8. Manage Firewalld
10:56
With the firewall running, there are several
10:58
different commands that you can use to manage it.
11:01
We use the ‘firewall-cmd' command and add parameters
11:06
to control how the firewall operates and is configured.
11:09
A sampling of the commands are listed here.
11:11
Run the ‘firewall-cmd --state' command
11:16
to check the firewall's status.
11:19
You can also run ‘firewall-cmd --get-active-zones'
11:25
to display the default firewall zone configuration.
11:28
This particular firewall package comes with several
11:31
predefined firewall zones that you can use, starting
11:34
at extremely secure to not very secure at all.
11:38
Predefined zones include Home, External, Work, and Trusted.
11:43
The default zone most distributions predefine is Public,
11:47
but you can actually pick whichever one you want to use.
11:50
Once you have the firewall running and a default zone set
11:53
up, there may be situations in which you need to open a
11:56
particular firewall port to support a particular service.
12:00
For example, if the system is set up as a
12:03
web server, you must let web traffic through.
12:06
If you don't configure firewall exceptions,
12:08
the web traffic will be blocked.
12:10
Web servers typically use ports 80 and
12:12
443 or HTTP and HTTPS for web traffic.
12:18
We need to allow these ports to remain
12:20
open so that the web server is reachable.
12:23
To do this, we need to allow the right
12:25
ports and protocols through the firewall.
12:28
To enable web services, we open ports on the firewall.
12:31
To open ports, we add them to the
12:33
exception list on the firewall itself.
12:36
This is also done using the ‘firewall-cmd' command.
12:40
For example, we first use the ‘--permanent' parameter
12:43
to store the exception in the database so that it
12:46
remains persistent even if the computer is restarted.
12:50
Next, we need to define which zone we're
12:52
using and then the port we want open.
12:55
It's also possible to use the protocol rather than the
12:58
port number when placing exceptions into the firewall.
13:01
We place the exception in the firewalld
13:03
configuration with HTTPS by using the same
13:07
command but substituting the protocol.
13:10
The last thing we need to do is restart
13:12
the firewall or reload the configuration.
13:14
If the system is in use and we don't want to
13:17
disrupt it, we enter the ‘reload' command, which
13:20
allows the firewall daemon to continue running.
13:23
The new configuration is loaded and
13:25
activated for us in the background.
13:28
The last thing we need to do is restart
13:30
or reload the newly configured firewall.
13:32
This allows us to use these changes
13:34
immediately without rebooting the system.
13:37
The ‘reload' parameter leaves the firewall activated.
9. Summary
13:41
That's it for this lesson.
13:42
In this lesson, we discussed some procedures
13:44
to keep a Linux host safer from attacks.
13:47
We discussed removing unneeded services from your system
13:50
and using Nmap and Netstat to identify running services.
13:55
We also discussed how keeping the system current
13:57
with OS and program updates is important.
14:01
Finally, we ended by discussing the benefits of
14:03
implementing the host-based firewall called firewalld.