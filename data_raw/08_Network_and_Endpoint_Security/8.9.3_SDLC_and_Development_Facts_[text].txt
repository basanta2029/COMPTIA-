Security Pro 8.0

8.9.3 SDLC and Development Facts

Even though you may not be a software developer, most security professionals at some point work with software engineers who develop applications. And just like any other enterprise component, these applications need to be properly secured.

This lesson covers the following topics:

Waterfall development life cycle model
Agile development life cycle model
Coding errors
Error handling
Static code analysis
Software sandboxing
Waterfall Development Life Cycle Model

The most widely used development model is the Waterfall model. It is called this because each step is completed before the next step is begun so that each step flows to the next.

The Waterfall development life cycle model steps are:

Step
Description
Requirements	All requirements for the application being developed are gathered from the client, user, or stakeholder.
Design	The software is documented, diagramed, and designed.
Implementation	The code is written.
Testing	A quality assurance team makes sure requirements are met, the code works properly across devices, and security issues are noted.
Deployment	The application is released to a client or the public.
Maintenance	The application is monitored for bugs or problems that are patched or fixed while in use. This is an ongoing stage that continues throughout the life of the app.
Understand that an application will likely go through some of these steps multiple times before moving to the next step. For example, the application might go through the Design step five times before itâ€™s ready to move to the Implementation step. Or the application may move back from the Implementation stage to the Design stage if a new feature needs to be added.

Note:
This entire development life cycle is a slow process and may take months or years to complete. The Waterfall method also lacks flexibility since the requirements determined in the beginning are carried through to the end product.

Description
Agile Development Life Cycle Model

A more agile approach was introduced in 2001 that approaches software development as a continuous, changing process with never-ending versions, bug fixes, and enhancements. This approach is aptly named Agile.

The Agile model works in this manner:

It breaks development into smaller time frames called Sprints.
Each Sprint has a specific duration(usually two to three weeks).
Developers work on one feature during a Sprint.
At the end of each Sprint, developers move on to the next feature.
Testing is performed throughout the development cycle.

Description
Coding Errors

Coding errors and design flaws are the main causes of software vulnerabilities. We can categorize these errors into two types:

Coding Error Type
Description
Compile	
An error that occurs during the building or compilation stage
Error compromises the software implementation
Prevents the app from running
Runtime	
An error that occurs while software is running
Sometimes called bugs
Error Handling

A well-written application must be able to handle errors and  exceptions gracefully. This means that the application performs in a controlled way when something unpredictable happens. An error or exception could be caused by invalid user input, a loss of network connectivity, another server or process failing, etc. Ideally, the programmer will have written a  structured exception handler (SEH) to dictate what the application should do. Each procedure can have multiple exception handlers.

Some handlers will deal with anticipated errors and exceptions; there should also be a catchall handler that will deal with the unexpected. The main goal must be for the application not to fail in a way that allows the attacker to execute code or perform some sort of injection attack. One infamous example of a poorly written exception handler is the Apple GoTo bug( nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch ).

Another issue is that an application's interpreter may default to a standard handler and display default error messages when something goes wrong. These may reveal platform information and the inner workings of code to an attacker. It is better for an application to use custom error handlers so that the developer can choose the amount of information shown when an error is caused.

Technically, an error is a condition that the process cannot recover from, such as the system running out of memory. An exception is a type of error that can be handled by a block of code without the process crashing. Note that exceptions are still described as generating error codes/messages, however.
Static Code Analysis

Static code analysis is a crucial software development practice. It involves scrutinizing source code to identify potential vulnerabilities, errors, and non-compliant coding practices before the program is finalized. By examining code in a 'static' state, developers can catch and rectify issues early in the development lifecycle. This makes it a proactive approach to building secure, reliable, high-quality software.

Application security approaches focus on software development and deployment lifecycles, with a heavy emphasis on secure coding practices that encourage developers to write code that prevents common vulnerabilities like SQL injection and cross-site scripting. Application security practices also mandate static and dynamic application security testing(SAST). Coding practices designed to support regular patching and updates are crucial to support the prompt resolution of newly discovered vulnerabilities.

Static code analysis supports secure coding and is performed using specialized tools, often integrated into software development suites. These tools automate code checks against pre-determined rules and flag potential issues so developers can review and address them. Some commonly used static analysis tools include SonarQube, Coverity, and Fortify, but there are many others.

Static code analysis in software development is critical because it enables early detection of bugs and security vulnerabilities and helps prevent potentially catastrophic failures in the final product. It also improves code quality and maintainability by enforcing coding standards and best practices. Additionally, static code analysis helps educate developers about common coding errors and security risks, which helps promote security-conscious development practices.

During the coding and design phases of development, you can increase development and application security by implementing a few key practices. Integrate security testing into each step in the development process.

Secure Testing Method
Description
Static application security testing	
Known as white box testing
Focuses on analyzing source code, binaries, and byte code early in the development process
Good at identifying things like SQL injections and buffer overflows
Can identify the exact cause of a coding problem:
Only in code that's written but not deployed
Is language specific
Can run continually and be widely applied
Has a high percentage of false positives
Limited in the types of vulnerabilities it can detect
Dynamic application security testing	
Known as black box testing
Scans applications after deployment
Tests from the outside
Uses a series of tests to determine vulnerabilities and flaws
Not language specific
Has fewer false positives
Hard to automate
Cannot pinpoint the cause of a flaw
Can take up to a week to complete the testing process
Interactive application security testing	
Has two types:

Passive:
Interactive functionality is built into static application security testing.
Uses source code scanners during runtime.
Active:
Testing tools can access interpreters and compilers, allowing precise identification of a problematic line of code in runtime.
Speeds up testing and remediation.
Can help in the Development stage by catching vulnerabilities early.
Can help in the QA stage by adding automated security checkpoints.
Can help in the Production stage through continuous monitoring.
Software Sandboxing

Sandboxing is a security mechanism used in software development and operation to isolate running processes from each other or prevent them from accessing the system they are running on. A sandbox is a protection feature designed to control a program so it runs with highly restrictive access. This containment strategy reduces the potential impact of malicious or malfunctioning software, making it effective for improving system security and stability and mitigating risks associated with software.

A practical example of sandboxing is implemented in modern web browsers, like Google Chrome, which separates each tab and extension into distinct processes. If a website or browser extension in one browser tab attempts to run malicious code, it is confined within that tab's sandbox. This action prevents malicious code from impacting the entire browser or underlying operating system. Similarly, if a tab crashes, it doesn't cause the whole browser to fail, improving reliability.

Operating systems also utilize sandboxing to isolate applications. For example, iOS and Android use sandboxing to limit each application's actions. An app in a sandbox can access its own data and resources but cannot access other app data or any nonessential system resources without explicit permission. This approach limits the damage caused by poorly written or malicious apps.

Virtual machines(VMs) and containers like Docker offer another example of sandboxing at a larger scale. Each VM or container can run in isolation, separated from the host and each other. The others remain unaffected if one VM or container experiences a security breach or system failure.
