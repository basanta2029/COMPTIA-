{
  "metadata": {
    "chapter_num": "4",
    "section_num": "4.6.12",
    "title": "Configure SELinux",
    "content_type": "video",
    "filename": "4.6.12_Configure_SELinux_[video].txt",
    "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.12_Configure_SELinux_[video].txt",
    "word_count": 735,
    "has_content": true
  },
  "full_content": "In this lesson, we're going to review SELinux, or Secure Linux. SELinux allows for a more granular approach to securing Linux from the outside world. This version is installed on most RHEL- or CentOS-based distributions by default. In order to properly configure SELinux, we need to elevate to the root account. Let's do the sestatus command to see if SELinux is running already. We see the current mode is enforcing. We'll go over that in a little bit. We use the getenforce command to view the current SELinux mode. This lets us know if the system is enforcing the right properties. We can change enforcement modes with this setenforce command. Type setenforce 0 to change the mode to permissive. This will turn off the protections and controls of SELinux. When we run getenforce again, it's configured to permissive. Type setenforce 1 to change the mode back to enforcing. Now, these changes are temporary. Once we reboot, SELinux will load the configurations in the SELinux config file. Let's change directories to /etc/selinux and open the config file. We see that SELinux is enforcing, and the Linux type is targeted. This means SELinux will only monitor certain processes, and those processes will be protected. The minimum is a modification of the targeted policy. Once selected, they're protected. And MLS means multi-level security protection. We're just going to look at the targeted type in this demonstration. Let's exit our text editor. We're going run a program called getsebool. Getsebool is Boolean, meaning that it's either on or off. Now that's add -a for \"show all\". We see that there are many different Boolean settings for different processes. We're going to look only at the samba processes. Let's run getsebool -a | grep samba to filter only samba processes. The process we're looking to manage here is samba_enable_home_dirs. So, samba is the process that allows Linux to share files with Windows devices by appearing like a Windows file server. We don't want to enable home directories to be advertised on samba. Let's run setsebool samba_enable_home_dirs=off. Okay, when we rerun the filtered getsebool command, we see that samba_enable_home_dirs is now off. Again, this is a temporary setting. If we wanted to make the changes permanent, we'd type the same setsebool command but with a dash capital P for \"permanent\" and then samba_enable_home_dirs=off. Now we press Enter, and when the system reboots, samba home directories will be set to off. Let's move on. So, files take on different permissions with SELinux. Let's switch to the home directory and use touch file1 to create a file. Let's also see some additional SELinux components. Run ls -lZ file1. We see that the permissions are standard, with Read/write for the user and Read for the group. And then it's Read for everybody else. It's owned by root, and it's owned by a group called root as well. Now, though, we now have additional information. We have the user type, the role base, and the type of file that it is. We can change this new information if we want. You might do this because you want to alter who can change the file or something like that. It gives us an additional granularity of control. To do this, you'd use the change context command, called chcon. We're going to change the type from admin_home to a user_home type. Let's type chcon -t. Now, the -t is what changes the file type, not the role or user type. Okay, continue typing user_home_t file1. We identify the file type and the file we're making the change to. Let's run ls -lZ for file1, and we see that we've changed the type from admin_home to user_home. Let's say that the changes ended up being a mistake. We could restore the context with a command that changes everything back. We'd run restorecon, specify the file name, and it'd restore the original settings. When we run ls -lZ file1 again, we see the changes. And that's all for now. In this demonstration, we showed you some SELinux commands, including sestatus, getenforce, and setenforce. Then we modified some Boolean values with getsebool and setsebool. And we also used chcon to change and restore context.",
  "chunks": [
    {
      "chunk_id": "4.6.12_chunk_1",
      "content": "In this lesson, we're going to review SELinux, or Secure Linux. SELinux allows for a more granular approach to securing Linux from the outside world. This version is installed on most RHEL- or CentOS-based distributions by default. In order to properly configure SELinux, we need to elevate to the root account.",
      "summary": "This lesson covers SELinux (Secure Linux), a security feature that enhances the protection of Linux systems, particularly in RHEL and CentOS distributions. It emphasizes the importance of configuring SELinux for granular security control and requires root access for proper management. Understanding SELinux is crucial for implementing effective security measures in Linux environments.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.12",
        "title": "Configure SELinux",
        "content_type": "video",
        "filename": "4.6.12_Configure_SELinux_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.12_Configure_SELinux_[video].txt",
        "word_count": 735,
        "has_content": true
      },
      "section_header": "Manage SELinux",
      "timestamp_range": "00:00-00:22"
    },
    {
      "chunk_id": "4.6.12_chunk_2",
      "content": "Let's do the sestatus command to see if SELinux is running already. We see the current mode is enforcing. We'll go over that in a little bit.",
      "summary": "The SELinux Status section introduces the use of the `sestatus` command to check if SELinux is active on a system, highlighting that the current mode is set to enforcing. This indicates that SELinux is actively enforcing its security policies, which is crucial for maintaining system integrity and protecting against unauthorized access. Understanding SELinux modes and their implications is essential for effective security management in Linux environments.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.12",
        "title": "Configure SELinux",
        "content_type": "video",
        "filename": "4.6.12_Configure_SELinux_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.12_Configure_SELinux_[video].txt",
        "word_count": 735,
        "has_content": true
      },
      "section_header": "SELinux Status",
      "timestamp_range": "00:22-00:31"
    },
    {
      "chunk_id": "4.6.12_chunk_3",
      "content": "We use the getenforce command to view the current SELinux mode. This lets us know if the system is enforcing the right properties. We can change enforcement modes with this setenforce command. Type setenforce 0 to change the mode to permissive. This will turn off the protections and controls of SELinux. When we run getenforce again, it's configured to permissive. Type setenforce 1 to change the mode back to enforcing. Now, these changes are temporary. Once we reboot, SELinux will load the configurations in the SELinux config file.",
      "summary": "The SELinux Mode section covers how to manage SELinux enforcement levels using the commands `getenforce` and `setenforce`. The `getenforce` command displays the current mode, while `setenforce` allows users to switch between permissive (0) and enforcing (1) modes, affecting system security controls. It's important to note that changes made with `setenforce` are temporary and will revert to the configurations specified in the SELinux config file upon reboot.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.12",
        "title": "Configure SELinux",
        "content_type": "video",
        "filename": "4.6.12_Configure_SELinux_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.12_Configure_SELinux_[video].txt",
        "word_count": 735,
        "has_content": true
      },
      "section_header": "SELinux Mode",
      "timestamp_range": "00:31-01:06"
    },
    {
      "chunk_id": "4.6.12_chunk_4",
      "content": "Let's change directories to /etc/selinux and open the config file. We see that SELinux is enforcing, and the Linux type is targeted. This means SELinux will only monitor certain processes, and those processes will be protected. The minimum is a modification of the targeted policy. Once selected, they're protected. And MLS means multi-level security protection. We're just going to look at the targeted type in this demonstration.",
      "summary": "The SELinux types section focuses on the configuration and enforcement of SELinux policies, specifically highlighting the targeted type, which monitors and protects specific processes within a Linux environment. The targeted policy offers a minimum level of security by safeguarding selected processes, while the multi-level security (MLS) option provides a more comprehensive protection scheme. This content emphasizes practical applications of SELinux in enhancing system security through effective policy management.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.12",
        "title": "Configure SELinux",
        "content_type": "video",
        "filename": "4.6.12_Configure_SELinux_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.12_Configure_SELinux_[video].txt",
        "word_count": 735,
        "has_content": true
      },
      "section_header": "SELinux Types",
      "timestamp_range": "01:06-01:36"
    },
    {
      "chunk_id": "4.6.12_chunk_5",
      "content": "Let's exit our text editor. We're going run a program called getsebool. Getsebool is Boolean, meaning that it's either on or off. Now that's add -a for \"show all\". We see that there are many different Boolean settings for different processes. We're going to look only at the samba processes. Let's run getsebool -a | grep samba to filter only samba processes. The process we're looking to manage here is samba_enable_home_dirs. So, samba is the process that allows Linux to share files with Windows devices by appearing like a Windows file server. We don't want to enable home directories to be advertised on samba. Let's run setsebool samba_enable_home_dirs=off. Okay, when we rerun the filtered getsebool command, we see that samba_enable_home_dirs is now off. Again, this is a temporary setting. If we wanted to make the changes permanent, we'd type the same setsebool command but with a dash capital P for \"permanent\" and then samba_enable_home_dirs=off. Now we press Enter, and when the system reboots, samba home directories will be set to off. Let's move on.",
      "summary": "The getsebool command in Linux is used to view and manage Boolean settings for various processes, specifically focusing on the samba service, which facilitates file sharing between Linux and Windows systems. By filtering the settings to only display samba-related options, users can disable the samba_enable_home_dirs feature to prevent home directories from being shared. To make this change permanent, the setsebool command can be used with the -P flag, ensuring the setting persists after system reboots.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.12",
        "title": "Configure SELinux",
        "content_type": "video",
        "filename": "4.6.12_Configure_SELinux_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.12_Configure_SELinux_[video].txt",
        "word_count": 735,
        "has_content": true
      },
      "section_header": "getsebool",
      "timestamp_range": "01:36-02:59"
    },
    {
      "chunk_id": "4.6.12_chunk_6",
      "content": "So, files take on different permissions with SELinux. Let's switch to the home directory and use touch file1 to create a file. Let's also see some additional SELinux components. Run ls -lZ file1. We see that the permissions are standard, with Read/write for the user and Read for the group. And then it's Read for everybody else. It's owned by root, and it's owned by a group called root as well. Now, though, we now have additional information. We have the user type, the role base, and the type of file that it is.",
      "summary": "In the SELinux Permissions section, learners explore how SELinux enhances file permissions beyond standard Unix permissions by incorporating user types, roles, and file types. By creating a file and examining its attributes with the `ls -lZ` command, students observe the additional security context provided by SELinux, which includes ownership and access controls. This practical application emphasizes the importance of SELinux in enforcing security policies on files and directories in a Linux environment.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.12",
        "title": "Configure SELinux",
        "content_type": "video",
        "filename": "4.6.12_Configure_SELinux_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.12_Configure_SELinux_[video].txt",
        "word_count": 735,
        "has_content": true
      },
      "section_header": "SELinux Permissions",
      "timestamp_range": "02:59-03:34"
    },
    {
      "chunk_id": "4.6.12_chunk_7",
      "content": "We can change this new information if we want. You might do this because you want to alter who can change the file or something like that. It gives us an additional granularity of control. To do this, you'd use the change context command, called chcon. We're going to change the type from admin_home to a user_home type. Let's type chcon -t. Now, the -t is what changes the file type, not the role or user type. Okay, continue typing user_home_t file1. We identify the file type and the file we're making the change to. Let's run ls -lZ for file1, and we see that we've changed the type from admin_home to user_home. Let's say that the changes ended up being a mistake. We could restore the context with a command that changes everything back. We'd run restorecon, specify the file name, and it'd restore the original settings. When we run ls -lZ file1 again, we see the changes.",
      "summary": "The chcon command is utilized to change the security context of files in a Linux environment, allowing for more granular control over file permissions. By using the command with the -t option, users can modify the file type, such as changing from admin_home to user_home. If a mistake is made, the restorecon command can revert the file to its original context, ensuring proper security settings are maintained.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.12",
        "title": "Configure SELinux",
        "content_type": "video",
        "filename": "4.6.12_Configure_SELinux_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.12_Configure_SELinux_[video].txt",
        "word_count": 735,
        "has_content": true
      },
      "section_header": "chcon Command",
      "timestamp_range": "03:34-04:37"
    },
    {
      "chunk_id": "4.6.12_chunk_8",
      "content": "And that's all for now. In this demonstration, we showed you some SELinux commands, including sestatus, getenforce, and setenforce. Then we modified some Boolean values with getsebool and setsebool. And we also used chcon to change and restore context.",
      "summary": "This section demonstrates key SELinux commands essential for managing security contexts in Linux environments. It covers the use of `sestatus`, `getenforce`, and `setenforce` for status checks and enforcement modes, as well as `getsebool` and `setsebool` for modifying Boolean values. Additionally, the `chcon` command is introduced for changing and restoring file security contexts, highlighting practical applications in system security management.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.12",
        "title": "Configure SELinux",
        "content_type": "video",
        "filename": "4.6.12_Configure_SELinux_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.12_Configure_SELinux_[video].txt",
        "word_count": 735,
        "has_content": true
      },
      "section_header": "Summary",
      "timestamp_range": "04:37-04:55"
    }
  ],
  "num_chunks": 8
}