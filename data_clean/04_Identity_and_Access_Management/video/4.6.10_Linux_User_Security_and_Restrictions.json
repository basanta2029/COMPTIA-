{
  "metadata": {
    "chapter_num": "4",
    "section_num": "4.6.10",
    "title": "Linux User Security and Restrictions",
    "content_type": "video",
    "filename": "4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
    "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
    "word_count": 1322,
    "has_content": true
  },
  "full_content": "If you manage Linux systems, one of your key responsibilities is ensuring user security. Today, user security is paramount, and you need to ensure that the data on your systems is secure. There are many aspects to configuring strong user security. Some are implemented by the Linux operating system itself, such as using the chage command to configure password aging, using ulimit to specify limits on resources, and so on. Other aspects involve user training, such as using strong passwords. You need to train your users to use strong passwords. Have them create passwords that are more than eight characters in length. They should have numbers in the passwords as well as letters. They should use uppercase and lowercase characters in the password, and it should not be a word found in the dictionary. If you teach users these basic principles it'll go a long way in preventing them from using weak passwords. Another thing you can do is configure your user passwords to expire after a period of time. This is called password aging. The longer a user has the same password, the more likely it is that it will be compromised at some point. Some organizations may mandate a maximum password age of 30 days. Others may specify 60 days. Others may even be 90 days. You can configure password aging using the chage command, which stands for change age. The syntax for using chage is shown here. We enter chage at the shell prompt followed by the options we want to specify, and then the name of the user we want to apply the password aging policy to. You can use the option shown here with the chage command. You can enter -m, followed by a number, which represents the minimum number of days required between password changes. You can use -M, followed by a number, which represents the maximum number of days allowed between password changes, and then the -W option, which specifies the number of warning days before the password change is required. You can use this option to specify how far in advance users need to be warned of an expiring password. Next, let's talk about configuring user limits. You can impose limits on how many times users may log concurrently into your system. You can configure how much CPU time they're allowed to use. You can configure how much system RAM they're allowed to use, and so on. This is done using a Pluggable Authentication Module (PAM) named pam_limits. You configure the pam_limits module using a file in the /etc/security directory named limits.conf. The syntax you use in the limits.conf file is shown here. First, you specify the entity you're going to apply the limit to. This could be a user, it could be a group, or you could use a wildcard character. For example, you could use an asterisk to apply a limit to all users. To apply them to a specific user, you enter the user name. To apply them to a group, you have to put an —œat— sign in front of its name to indicate that this is a group, not a user name. Next you identify the type of limit you want to set. You can use two different values, either a hard limit or a soft limit. A hard limit is a limit that cannot be exceeded. A soft limit is a limit that the user is allowed to exceed temporarily. Next you specify the limit you want to apply. There are lots of different values you can use in the limit field. Some of the more useful ones are listed here. First is core, which specifies the size of the user's core files. Next is data, which specifies how much room a program can use in RAM. Then we have fsize, which limits the size of the files that the user can create. We have nofile, which limits the number of open data files the user can have. You can specify CPU, which specifies a limit in terms of the amount of CPU time a single process can use. We have nproc, which limits the number of concurrent processes. We have maxlogins, which limits the number of simultaneous logins. And then we have priority, which is used to set process priority limits. Then you specify a value for the limit you specified. In this example, suppose I want to configure the rtracy user with a hard CPU limit that limits a single process to five minutes maximum of CPU time. To do this, in the limits.conf file I would enter rtracy hard cpu 5. In addition to using the limits.conf file, you can also use the ulimit command at the shell prompt to configure resource limits for a given user on your Linux system. It can be used to either view the user's current resource usage limits or you can use it to set the user's current resource usage limits. It's important to note that the ulimit command only restricts access to resources for programs that are launched from the shell prompt as that user account. If you're running graphical applications, the ulimit resource limits are not applied. Limits that you set with the command will only be applied to executables that are launched from the shell prompt. They will not be applied to applications that might be launched graphically, such as double-clicking on an icon in the graphical desktop. Let's take a look at the syntax for using ulimit. We enter ulimit, followed by the options we want to apply, and then the limit we want to set. Some of the options you can use with ulimit are listed here. These are not all of the options. If you want to see all of them open up the ulimits man page. These are just some of the more useful ones here. -c is used to set the maximum size of core files. If you have an application that crashes, and it needs to make a core dump, you can use this option to specify how big those dump files can be. This is usually set to zero by default so that no core dump files can be created. If you do want to enable core dump files, set it to a different value. The next option is -f. This is used to set the maximum size of files that are created by a shell session. -n is used to set the maximum number of open files on the system. Next is the -t option, which allows us to set the maximum amount of CPU time (in seconds) a process can use. Next is the -u option, which specifies the maximum amount of processes a single user is allowed to run. Next is the -d option, which allows us to specify the maximum size in memory that a particular process's data segment can occupy. We have -H that allows us to set a hard resource limit, and then we have -S, which allows us to set a soft resource limit. If you want to just view the limits that are currently assigned you can use the -a option. For example, if you enter ulimit -a, it displays all the limits that have been configured for my user account. Suppose we want to limit the user to a maximum of 5 concurrent processes on the system, and we want it to be a soft limit we'll allow them to exceed it temporarily, if necessary. To do this, we would enter ulimit -S -u 5. That's it for this lesson. We discussed some basic Linux user security principles that you should be aware of, such as using strong passwords, aging passwords, and configuring user limits.",
  "chunks": [
    {
      "chunk_id": "4.6.10_chunk_1",
      "content": "If you manage Linux systems, one of your key responsibilities is ensuring user security. Today, user security is paramount, and you need to ensure that the data on your systems is secure.",
      "summary": "Linux system administrators must prioritize user security management to protect system data integrity and prevent unauthorized access. Effective user security involves implementing proper access controls, user restrictions, and authentication mechanisms to ensure only authorized users can access sensitive system resources. These security measures are critical for maintaining overall system security and preventing data breaches in Linux environments.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.10",
        "title": "Linux User Security and Restrictions",
        "content_type": "video",
        "filename": "4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "word_count": 1322,
        "has_content": true
      },
      "section_header": "Linux User Security and Restrictions",
      "timestamp_range": "00:00-00:16"
    },
    {
      "chunk_id": "4.6.10_chunk_2",
      "content": "There are many aspects to configuring strong user security. Some are implemented by the Linux operating system itself, such as using the chage command to configure password aging, using ulimit to specify limits on resources, and so on. Other aspects involve user training, such as using strong passwords. You need to train your users to use strong passwords. Have them create passwords that are more than eight characters in length. They should have numbers in the passwords as well as letters. They should use uppercase and lowercase characters in the password, and it should not be a word found in the dictionary. If you teach users these basic principles it'll go a long way in preventing them from using weak passwords. Another thing you can do is configure your user passwords to expire after a period of time. This is called password aging. The longer a user has the same password, the more likely it is that it will be compromised at some point. Some organizations may mandate a maximum password age of 30 days. Others may specify 60 days. Others may even be 90 days. You can configure password aging using the chage command, which stands for change age. The syntax for using chage is shown here. We enter chage at the shell prompt followed by the options we want to specify, and then the name of the user we want to apply the password aging policy to. You can use the option shown here with the chage command. You can enter -m, followed by a number, which represents the minimum number of days required between password changes. You can use -M, followed by a number, which represents the maximum number of days allowed between password changes, and then the -W option, which specifies the number of warning days before the password change is required. You can use this option to specify how far in advance users need to be warned of an expiring password.",
      "summary": "Linux user security involves implementing strong password policies through user training (8+ characters, mixed case, numbers, non-dictionary words) and technical controls like password aging using the chage command. The chage command configures password expiration policies with options for minimum days between changes (-m), maximum days allowed (-M), and warning period before expiration (-W). Password aging forces regular password updates (typically 30-90 days) to reduce compromise risk from long-term password exposure.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.10",
        "title": "Linux User Security and Restrictions",
        "content_type": "video",
        "filename": "4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "word_count": 1322,
        "has_content": true
      },
      "section_header": "chage Command",
      "timestamp_range": "00:16-01:59"
    },
    {
      "chunk_id": "4.6.10_chunk_3",
      "content": "Next, let's talk about configuring user limits. You can impose limits on how many times users may log concurrently into your system. You can configure how much CPU time they're allowed to use. You can configure how much system RAM they're allowed to use, and so on. This is done using a Pluggable Authentication Module (PAM) named pam_limits. You configure the pam_limits module using a file in the /etc/security directory named limits.conf.",
      "summary": "Linux systems use the pam_limits Pluggable Authentication Module (PAM) to enforce user resource restrictions including concurrent login sessions, CPU time allocation, and system RAM usage. These security limits are configured through the limits.conf file located in the /etc/security directory to prevent resource abuse and maintain system stability.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.10",
        "title": "Linux User Security and Restrictions",
        "content_type": "video",
        "filename": "4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "word_count": 1322,
        "has_content": true
      },
      "section_header": "User Limits",
      "timestamp_range": "01:59-02:26"
    },
    {
      "chunk_id": "4.6.10_chunk_4",
      "content": "The syntax you use in the limits.conf file is shown here. First, you specify the entity you're going to apply the limit to. This could be a user, it could be a group, or you could use a wildcard character. For example, you could use an asterisk to apply a limit to all users. To apply them to a specific user, you enter the user name. To apply them to a group, you have to put an —œat— sign in front of its name to indicate that this is a group, not a user name. Next you identify the type of limit you want to set. You can use two different values, either a hard limit or a soft limit. A hard limit is a limit that cannot be exceeded. A soft limit is a limit that the user is allowed to exceed temporarily. Next you specify the limit you want to apply. There are lots of different values you can use in the limit field. Some of the more useful ones are listed here. First is core, which specifies the size of the user's core files. Next is data, which specifies how much room a program can use in RAM. Then we have fsize, which limits the size of the files that the user can create. We have nofile, which limits the number of open data files the user can have. You can specify CPU, which specifies a limit in terms of the amount of CPU time a single process can use. We have nproc, which limits the number of concurrent processes. We have maxlogins, which limits the number of simultaneous logins. And then we have priority, which is used to set process priority limits. Then you specify a value for the limit you specified. In this example, suppose I want to configure the rtracy user with a hard CPU limit that limits a single process to five minutes maximum of CPU time. To do this, in the limits.conf file I would enter rtracy hard cpu 5.",
      "summary": "The limits.conf file controls Linux user resource restrictions using syntax: entity (user/group/@group/wildcard) + limit type (hard/soft) + resource limit + value. Hard limits cannot be exceeded while soft limits allow temporary overages, with configurable restrictions including CPU time, file sizes, concurrent processes, simultaneous logins, and memory usage. Example: \"rtracy hard cpu 5\" sets a hard 5-minute CPU limit per process for user rtracy.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.10",
        "title": "Linux User Security and Restrictions",
        "content_type": "video",
        "filename": "4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "word_count": 1322,
        "has_content": true
      },
      "section_header": "limits.conf File Configuration",
      "timestamp_range": "02:26-04:12"
    },
    {
      "chunk_id": "4.6.10_chunk_5",
      "content": "In addition to using the limits.conf file, you can also use the ulimit command at the shell prompt to configure resource limits for a given user on your Linux system. It can be used to either view the user's current resource usage limits or you can use it to set the user's current resource usage limits. It's important to note that the ulimit command only restricts access to resources for programs that are launched from the shell prompt as that user account. If you're running graphical applications, the ulimit resource limits are not applied. Limits that you set with the command will only be applied to executables that are launched from the shell prompt. They will not be applied to applications that might be launched graphically, such as double-clicking on an icon in the graphical desktop. Let's take a look at the syntax for using ulimit. We enter ulimit, followed by the options we want to apply, and then the limit we want to set. Some of the options you can use with ulimit are listed here. These are not all of the options. If you want to see all of them open up the ulimits man page. These are just some of the more useful ones here. -c is used to set the maximum size of core files. If you have an application that crashes, and it needs to make a core dump, you can use this option to specify how big those dump files can be. This is usually set to zero by default so that no core dump files can be created. If you do want to enable core dump files, set it to a different value. The next option is -f. This is used to set the maximum size of files that are created by a shell session. -n is used to set the maximum number of open files on the system. Next is the -t option, which allows us to set the maximum amount of CPU time (in seconds) a process can use. Next is the -u option, which specifies the maximum amount of processes a single user is allowed to run. Next is the -d option, which allows us to specify the maximum size in memory that a particular process's data segment can occupy. We have -H that allows us to set a hard resource limit, and then we have -S, which allows us to set a soft resource limit. If you want to just view the limits that are currently assigned you can use the -a option. For example, if you enter ulimit -a, it displays all the limits that have been configured for my user account. Suppose we want to limit the user to a maximum of 5 concurrent processes on the system, and we want it to be a soft limit we'll allow them to exceed it temporarily, if necessary. To do this, we would enter ulimit -S -u 5.",
      "summary": "The ulimit command configures resource limits for Linux users to restrict system resource consumption and prevent resource exhaustion attacks, but only applies to programs launched from the shell prompt, not graphical applications. Key security options include limiting maximum processes (-u), CPU time (-t), open files (-n), and file sizes (-f), with both hard (-H) and soft (-S) limits available to control user access to system resources.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.10",
        "title": "Linux User Security and Restrictions",
        "content_type": "video",
        "filename": "4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "word_count": 1322,
        "has_content": true
      },
      "section_header": "ulimit Command",
      "timestamp_range": "04:12-07:00"
    },
    {
      "chunk_id": "4.6.10_chunk_6",
      "content": "That's it for this lesson. We discussed some basic Linux user security principles that you should be aware of, such as using strong passwords, aging passwords, and configuring user limits.",
      "summary": "This lesson covered essential Linux user security principles including implementing strong password policies, configuring password aging requirements, and establishing user account limits to restrict system access. These fundamental access controls help prevent unauthorized system compromise and enforce security boundaries in Linux environments. Password management and user restriction configurations are critical components of Linux system hardening and user account security.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.6.10",
        "title": "Linux User Security and Restrictions",
        "content_type": "video",
        "filename": "4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.6.10_Linux_User_Security_and_Restrictions_[video].txt",
        "word_count": 1322,
        "has_content": true
      },
      "section_header": "Summary",
      "timestamp_range": "07:00-07:11"
    }
  ],
  "num_chunks": 6,
  "document_summary": "Linux User Security and Restrictions (video): If you manage Linux systems, one of your key responsibilities is ensuring user security. Today, user security is paramount, and you need to ensure that the data on your systems is secure. This is done using a Pluggable Authentication Module (PAM) named pam_limits."
}