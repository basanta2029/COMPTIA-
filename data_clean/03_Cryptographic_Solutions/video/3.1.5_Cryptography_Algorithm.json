{
  "metadata": {
    "chapter_num": "3",
    "section_num": "3.1.5",
    "title": "Cryptography Algorithm",
    "content_type": "video",
    "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
    "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
    "word_count": 1544,
    "has_content": true
  },
  "full_content": "In this lesson, we're going to take a deeper dive into the world of cryptography. The cornerstone of cryptography is the algorithm, or cipher. Cipher is just a fancy word for the series of steps that are taken for data to be encrypted or decrypted. In this video, we're going to look at several types of ciphers and how they work. One of the first cipher types is the stream cipher. A stream cipher is a symmetric encryption method that encrypts 1 bit of plaintext at a time. This method is based on the one-time pad, or OTP, which was very popular during World War 2. OTP uses a symmetric encryption key that should be as long or even longer than the data being encrypted. For example, if you had a small message that was only 15 bits long, a random 15-bit key would need to be generated. That key can then be used to encrypt your message using a process called Exclusive-ORing, or XORing. XORing means that we compare two strings, our message and our random key, to generate an output. We do this by lining them both up. If the bits match, a 0 is generated. If they don't match, a 1 is generated. The output is our ciphertext! What makes this so interesting is that this demonstrates perfect secrecy. This means that, to a hacker, this ciphertext looks completely random. It would be just as difficult to brute-force the key as it would be to brute-force the data itself. OTP only works properly if our secret key is only used once. If we use it more than once, a hacker could then start to decode the secret key. OTP works great if we're dealing with small messages. But what if we needed to encrypt every video in this course? A video can range from 500 megabytes to up to 5 gigs or more. Since every video file would need to generate a key that's the same size or larger than the video, we would quickly end up running out of hard drive space. So with today's data types, the one-time pad just isn't very practical. Stream ciphers offer a solution to this problem. A stream cipher can use a smaller fixed-length key that can be used repeatedly throughout the encryption process. This key is called a seed key, and in our example we'll say that it's 2048 bits. This key is run through a pseudorandom number generator which outputs a new and unique encryption key called a keystream. Notice that this new key matches the size of our data. The keystream is then XORed with the data to give us our ciphertext. While stream ciphers are less secure than the one-time pad, the advantage to this method is that it can be used in real time. One of the most widely used stream ciphers was RC4. But due to multiple vulnerabilities discovered, it's no longer in use. Many symmetric encryption algorithms use the block cipher method. With block ciphers, instead of encrypting our data one bit at a time, the data is encrypted one chunk or block at a time. The common block sizes used are 64, 128, or 256 bits in length. For example, let's say that we want to encrypt a file that's 800 bits in size. Using a 256-bit block size, the data will be encrypted 256 bits, or 32 bytes, at a time until the process is complete. Since the last block ends up being smaller than 256 bits, the algorithm pads the block with some random data to bring it up to 256 bits. As shown here, there are several block cipher operation modes that can be utilized depending on the application or use. Let's talk about a few of them. Electronic Code Book Mode, or ECB, is the simplest block cipher operation mode. With this mode, each block of plaintext data is encrypted separately. Several blocks can be encrypted at the same time, allowing for faster encryption. The biggest disadvantage is that identical data results in the same ciphertext, meaning that a hacker would be able to decipher some of the data if they intercept multiple blocks. Cipher Block Chaining is like ECB, except that it uses an initialization vector. The initialization vector is a starting variable that's XORed with the current block's plaintext to encrypt the data. The first initialization vector is a random string and each subsequent initialization vector is the ciphertext from the previous block. CBC is more secure than ECB but slower because multiple blocks can't be encrypted at the same time. Cipher Feedback Mode, or CFB, also utilizes an initialization vector. But instead of using it on the plaintext, the initialization vector is encrypted and then that result is XORed with the plaintext to create the ciphertext block. This is the equivalent of encrypting the plaintext with a one-time pad. Output Feedback Mode, or OFB, is practically identical to Cipher Feedback Mode. The difference is the initialization vector used after the first round of encryption. The CFB's output is XORed with the plaintext and the result is the next block's initialization vector. The process is the same in Output Feedback Mode, except that the encryption's output is the next block's initialization vector before it's XORed with the plaintext. Next we have Counter Mode. Similar to ECB, every encryption process in Counter Mode is separate. Instead of using an initialization vector, Counter Mode uses a nonce combined with an encrypted counter. Nonce is simply a fancy word for a random string that's used for all blocks. The nonce's encrypted output and counter are then XORed with the plaintext to create the ciphertext. The counter starts at 0 and increments every block. By combining the nonce and counter, each block is using a different value so that even if the data is the same, the output will be different. If we want to provide authentication with confidentiality, we can use the Galois Counter Mode, or GCM. This mode works just like Counter Mode. First, we have the counter and nonce encrypted. The output is XOR-ed with the plaintext to give us the ciphertext. Here's where things get different. The ciphertext is combined with a special hash. That output contains the ciphertext along with a message authentication code that gives us assurance that the data hasn't been tampered with. Because this method is efficient and provides authentication, we see it used often with network communications such as wireless networks and web servers that use SSH or TLS. The other block cipher modes are classified as unauthenticated encryption and GCM is classified as authenticated encryption. There are some other encryption methods that authenticate, but the most common one is the Galois Counter Mode. We're putting more and more Internet of Things, or IoT, devices into our networks; the need to encrypt data has never been more important. In 2018, the National Institute of Standards and Technology, or NIST, began the process of standardizing encryption algorithms called lightweight cryptography for these types of devices. Many IoT devices are small, low-powered devices that don't have the resources to handle the encryption methods we've covered. IoT devices have limitations such as only having a small amount of RAM and CPU power. Some devices even run on batteries. Lightweight cryptography algorithms must take this into account and still provide high levels of security while being efficient. One huge risk with all encryption is that the data must first be decrypted before it can be used. Homomorphic encryption addresses this concern by allowing encrypted data to be used without decrypting it first. This is done by performing mathematical operations on the ciphertext instead of on the actual data itself. Homomorphic encryption works like other asymmetric encryption methods by using a public key to encrypt the data and a private key to decrypt it. It helps to look at data as math problems to better understand the differences in the types of homomorphic encryption. There are three types of homomorphic encryption: Partially homomorphic, which allows for only simple mathematical operations like addition and subtraction to be performed; somewhat homomorphic, which allows for more complex math such as multiplication to occur but only for a limited number of times; and fully homomorphic, which can handle any mathematical operation an unlimited number of times. Homomorphic Encryption has the potential to be a game changer, but as of now it's incredibly slow and inefficient. That's it for this lesson. In this lesson, we looked at the different ciphers used in cryptography. We first examined the stream cipher which encrypts data one bit at a time. Then we looked at how block ciphers work and the different operation modes. Finally, we looked at two newer forms of cryptography. Lightweight cryptography is being designed for IoT devices and homomorphic encryption allows data to be used without having to decrypt it.",
  "chunks": [
    {
      "chunk_id": "3.1.5_chunk_1",
      "content": "In this lesson, we're going to take a deeper dive into the world of cryptography. The cornerstone of cryptography is the algorithm, or cipher. Cipher is just a fancy word for the series of steps that are taken for data to be encrypted or decrypted. In this video, we're going to look at several types of ciphers and how they work.",
      "summary": "This lesson explores the fundamental role of cryptographic algorithms, or ciphers, in securing data through encryption and decryption processes. Key topics include various types of ciphers, their mechanisms, and practical applications in protecting sensitive information. Understanding these algorithms is essential for implementing effective security measures in cybersecurity practices.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Cryptography Algorithms",
      "timestamp_range": "00:00-00:23"
    },
    {
      "chunk_id": "3.1.5_chunk_2",
      "content": "One of the first cipher types is the stream cipher. A stream cipher is a symmetric encryption method that encrypts 1 bit of plaintext at a time. This method is based on the one-time pad, or OTP, which was very popular during World War 2. OTP uses a symmetric encryption key that should be as long or even longer than the data being encrypted.",
      "summary": "A stream cipher is a symmetric encryption technique that processes data one bit at a time, making it efficient for real-time applications. It is rooted in the one-time pad (OTP) concept, which requires a key that is at least as long as the plaintext, ensuring strong security. Stream ciphers are particularly useful in scenarios where data needs to be encrypted on-the-fly, such as in secure communications.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Stream Cipher",
      "timestamp_range": "00:23-00:46"
    },
    {
      "chunk_id": "3.1.5_chunk_3",
      "content": "For example, if you had a small message that was only 15 bits long, a random 15-bit key would need to be generated. That key can then be used to encrypt your message using a process called Exclusive-ORing, or XORing. XORing means that we compare two strings, our message and our random key, to generate an output. We do this by lining them both up. If the bits match, a 0 is generated. If they don't match, a 1 is generated. The output is our ciphertext! What makes this so interesting is that this demonstrates perfect secrecy. This means that, to a hacker, this ciphertext looks completely random. It would be just as difficult to brute-force the key as it would be to brute-force the data itself. OTP only works properly if our secret key is only used once. If we use it more than once, a hacker could then start to decode the secret key. OTP works great if we're dealing with small messages. But what if we needed to encrypt every video in this course? A video can range from 500 megabytes to up to 5 gigs or more. Since every video file would need to generate a key that's the same size or larger than the video, we would quickly end up running out of hard drive space. So with today's data types, the one-time pad just isn't very practical.",
      "summary": "The One-Time Pad (OTP) is a cryptographic method that achieves perfect secrecy by using a random key of the same length as the message, employing Exclusive-ORing (XORing) to generate ciphertext. While OTP is theoretically secure and resistant to brute-force attacks, its practicality is limited due to the requirement of a unique key for each message, making it unsuitable for larger data types like videos. Consequently, while OTP is effective for small messages, its application in modern cybersecurity is constrained by storage and key management challenges.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "One-Time Pad",
      "timestamp_range": "00:46-02:06"
    },
    {
      "chunk_id": "3.1.5_chunk_4",
      "content": "Stream ciphers offer a solution to this problem. A stream cipher can use a smaller fixed-length key that can be used repeatedly throughout the encryption process. This key is called a seed key, and in our example we'll say that it's 2048 bits. This key is run through a pseudorandom number generator which outputs a new and unique encryption key called a keystream. Notice that this new key matches the size of our data. The keystream is then XORed with the data to give us our ciphertext. While stream ciphers are less secure than the one-time pad, the advantage to this method is that it can be used in real time. One of the most widely used stream ciphers was RC4. But due to multiple vulnerabilities discovered, it's no longer in use.",
      "summary": "Stream ciphers utilize a fixed-length seed key, such as a 2048-bit key, to generate a unique keystream through a pseudorandom number generator, which is then XORed with the plaintext to produce ciphertext. While they offer real-time encryption capabilities, stream ciphers are generally considered less secure than one-time pads, with RC4 being a notable example that has fallen out of favor due to identified vulnerabilities. Understanding stream ciphers is crucial for recognizing their applications and limitations in modern encryption practices.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Stream Ciphers",
      "timestamp_range": "02:06-02:53"
    },
    {
      "chunk_id": "3.1.5_chunk_5",
      "content": "Many symmetric encryption algorithms use the block cipher method. With block ciphers, instead of encrypting our data one bit at a time, the data is encrypted one chunk or block at a time. The common block sizes used are 64, 128, or 256 bits in length. For example, let's say that we want to encrypt a file that's 800 bits in size. Using a 256-bit block size, the data will be encrypted 256 bits, or 32 bytes, at a time until the process is complete. Since the last block ends up being smaller than 256 bits, the algorithm pads the block with some random data to bring it up to 256 bits. As shown here, there are several block cipher operation modes that can be utilized depending on the application or use. Let's talk about a few of them.",
      "summary": "Block ciphers are a method of symmetric encryption that encrypt data in fixed-size chunks, typically 64, 128, or 256 bits, rather than bit by bit. When encrypting data, if the final block is smaller than the designated size, it is padded with random data to ensure uniformity. Various operation modes can be applied to block ciphers, allowing for flexibility based on specific application needs.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Block Ciphers",
      "timestamp_range": "02:53-03:45"
    },
    {
      "chunk_id": "3.1.5_chunk_6",
      "content": "Electronic Code Book Mode, or ECB, is the simplest block cipher operation mode. With this mode, each block of plaintext data is encrypted separately. Several blocks can be encrypted at the same time, allowing for faster encryption. The biggest disadvantage is that identical data results in the same ciphertext, meaning that a hacker would be able to decipher some of the data if they intercept multiple blocks.",
      "summary": "Electronic Code Book (ECB) is a basic block cipher mode that encrypts each block of plaintext independently, enabling parallel processing for faster encryption. However, its primary vulnerability lies in the fact that identical plaintext blocks produce identical ciphertext, which can expose patterns and make it easier for attackers to decipher the data if they capture multiple blocks. Therefore, while ECB offers speed, it is generally not recommended for secure encryption due to its lack of data confidentiality.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Electronic Code Book (ECB)",
      "timestamp_range": "03:45-04:12"
    },
    {
      "chunk_id": "3.1.5_chunk_7",
      "content": "Cipher Block Chaining is like ECB, except that it uses an initialization vector. The initialization vector is a starting variable that's XORed with the current block's plaintext to encrypt the data. The first initialization vector is a random string and each subsequent initialization vector is the ciphertext from the previous block. CBC is more secure than ECB but slower because multiple blocks can't be encrypted at the same time.",
      "summary": "Cipher Block Chaining (CBC) enhances security over Electronic Codebook (ECB) by incorporating an initialization vector (IV), which is XORed with the plaintext of each block to ensure that identical plaintext blocks produce different ciphertexts. The first IV is randomly generated, and subsequent IVs are derived from the ciphertext of the previous block, making CBC more secure but slower due to its sequential processing of blocks. This method is widely used in cryptographic applications where data integrity and confidentiality are paramount.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Cipher Block Chaining (CBC)",
      "timestamp_range": "04:12-04:41"
    },
    {
      "chunk_id": "3.1.5_chunk_8",
      "content": "Cipher Feedback Mode, or CFB, also utilizes an initialization vector. But instead of using it on the plaintext, the initialization vector is encrypted and then that result is XORed with the plaintext to create the ciphertext block. This is the equivalent of encrypting the plaintext with a one-time pad.",
      "summary": "Cipher Feedback Mode (CFB) is a block cipher mode that employs an initialization vector (IV) to enhance encryption security. In CFB, the IV is first encrypted, and the resulting output is XORed with the plaintext to produce the ciphertext, effectively functioning like a one-time pad. This method allows for the encryption of data streams, making it suitable for applications requiring real-time data processing and secure transmission.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Cipher Feedback Mode (CFB)",
      "timestamp_range": "04:41-05:01"
    },
    {
      "chunk_id": "3.1.5_chunk_9",
      "content": "Output Feedback Mode, or OFB, is practically identical to Cipher Feedback Mode. The difference is the initialization vector used after the first round of encryption. The CFB's output is XORed with the plaintext and the result is the next block's initialization vector. The process is the same in Output Feedback Mode, except that the encryption's output is the next block's initialization vector before it's XORed with the plaintext.",
      "summary": "Output Feedback Mode (OFB) is a block cipher mode similar to Cipher Feedback Mode (CFB), with the key distinction being the use of the encryption output as the initialization vector for the next block. In OFB, the output of the encryption is utilized directly as the initialization vector before being XORed with the plaintext, allowing for continuous encryption without the need for feedback from the ciphertext. This method enhances data security and is particularly useful in scenarios requiring error resilience and stream-like processing.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Output Feedback Mode (OFB)",
      "timestamp_range": "05:01-05:30"
    },
    {
      "chunk_id": "3.1.5_chunk_10",
      "content": "Next we have Counter Mode. Similar to ECB, every encryption process in Counter Mode is separate. Instead of using an initialization vector, Counter Mode uses a nonce combined with an encrypted counter. Nonce is simply a fancy word for a random string that's used for all blocks. The nonce's encrypted output and counter are then XORed with the plaintext to create the ciphertext. The counter starts at 0 and increments every block. By combining the nonce and counter, each block is using a different value so that even if the data is the same, the output will be different.",
      "summary": "Counter Mode is a cryptographic technique that enhances security by using a nonce and an encrypted counter instead of an initialization vector, ensuring that each block of plaintext is encrypted uniquely. The counter starts at zero and increments with each block, allowing for distinct ciphertext outputs even when identical plaintext is processed. This method effectively mitigates risks associated with patterns in data, making it a practical choice for secure encryption in various applications.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Counter Mode",
      "timestamp_range": "05:30-06:08"
    },
    {
      "chunk_id": "3.1.5_chunk_11",
      "content": "If we want to provide authentication with confidentiality, we can use the Galois Counter Mode, or GCM. This mode works just like Counter Mode. First, we have the counter and nonce encrypted. The output is XOR-ed with the plaintext to give us the ciphertext. Here's where things get different. The ciphertext is combined with a special hash. That output contains the ciphertext along with a message authentication code that gives us assurance that the data hasn't been tampered with. Because this method is efficient and provides authentication, we see it used often with network communications such as wireless networks and web servers that use SSH or TLS. The other block cipher modes are classified as unauthenticated encryption and GCM is classified as authenticated encryption. There are some other encryption methods that authenticate, but the most common one is the Galois Counter Mode.",
      "summary": "Galois Counter Mode (GCM) is an authenticated encryption method that combines the efficiency of Counter Mode with message authentication to ensure both confidentiality and data integrity. It encrypts data using a counter and nonce, then generates a message authentication code (MAC) to verify that the ciphertext has not been tampered with. GCM is widely used in secure network communications, such as SSH and TLS, making it a preferred choice for applications requiring robust security.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Galois Counter Mode (GCM)",
      "timestamp_range": "06:08-07:03"
    },
    {
      "chunk_id": "3.1.5_chunk_12",
      "content": "We're putting more and more Internet of Things, or IoT, devices into our networks; the need to encrypt data has never been more important. In 2018, the National Institute of Standards and Technology, or NIST, began the process of standardizing encryption algorithms called lightweight cryptography for these types of devices. Many IoT devices are small, low-powered devices that don't have the resources to handle the encryption methods we've covered. IoT devices have limitations such as only having a small amount of RAM and CPU power. Some devices even run on batteries. Lightweight cryptography algorithms must take this into account and still provide high levels of security while being efficient.",
      "summary": "Lightweight cryptography is essential for securing Internet of Things (IoT) devices, which often have limited processing power and memory. Initiated by NIST in 2018, this standardization focuses on developing efficient encryption algorithms that maintain robust security despite the constraints of small, low-powered devices. The practical application of lightweight cryptography ensures that IoT devices can securely transmit data while optimizing resource usage.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Lightweight Cryptography",
      "timestamp_range": "07:03-07:47"
    },
    {
      "chunk_id": "3.1.5_chunk_13",
      "content": "One huge risk with all encryption is that the data must first be decrypted before it can be used. Homomorphic encryption addresses this concern by allowing encrypted data to be used without decrypting it first. This is done by performing mathematical operations on the ciphertext instead of on the actual data itself. Homomorphic encryption works like other asymmetric encryption methods by using a public key to encrypt the data and a private key to decrypt it. It helps to look at data as math problems to better understand the differences in the types of homomorphic encryption. There are three types of homomorphic encryption: Partially homomorphic, which allows for only simple mathematical operations like addition and subtraction to be performed; somewhat homomorphic, which allows for more complex math such as multiplication to occur but only for a limited number of times; and fully homomorphic, which can handle any mathematical operation an unlimited number of times. Homomorphic Encryption has the potential to be a game changer, but as of now it's incredibly slow and inefficient.",
      "summary": "Homomorphic encryption enables the use of encrypted data without the need for decryption, allowing mathematical operations to be performed directly on ciphertext. It encompasses three types: partially homomorphic, somewhat homomorphic, and fully homomorphic, each varying in the complexity and number of operations allowed. While it presents significant potential for enhancing data security, current implementations are hindered by inefficiencies and slow processing speeds.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Homomorphic Encryption",
      "timestamp_range": "07:47-08:53"
    },
    {
      "chunk_id": "3.1.5_chunk_14",
      "content": "That's it for this lesson. In this lesson, we looked at the different ciphers used in cryptography. We first examined the stream cipher which encrypts data one bit at a time. Then we looked at how block ciphers work and the different operation modes. Finally, we looked at two newer forms of cryptography. Lightweight cryptography is being designed for IoT devices and homomorphic encryption allows data to be used without having to decrypt it.",
      "summary": "This lesson covers key cryptographic concepts, focusing on stream and block ciphers, including their operation modes. It also introduces emerging cryptographic methods such as lightweight cryptography for IoT devices and homomorphic encryption, which enables data processing without decryption. These topics highlight the importance of adapting encryption techniques to meet modern security needs.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.5",
        "title": "Cryptography Algorithm",
        "content_type": "video",
        "filename": "3.1.5_Cryptography_Algorithm_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.5_Cryptography_Algorithm_[video].txt",
        "word_count": 1544,
        "has_content": true
      },
      "section_header": "Summary",
      "timestamp_range": "08:53-09:18"
    }
  ],
  "num_chunks": 14
}