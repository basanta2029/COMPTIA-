{
  "metadata": {
    "chapter_num": "3",
    "section_num": "3.3.1",
    "title": "Hashing",
    "content_type": "video",
    "filename": "3.3.1_Hashing_[video].txt",
    "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
    "word_count": 981,
    "has_content": true
  },
  "full_content": "When you're transferring or downloading files, it's important to know that the file is legitimate and hasn't been altered in any way. This is what hashes are for. In this lesson, we'll discuss how hashing works, some common ways they're used, what hashing collisions are, and how to reduce collisions. Hashing is the process of generating a fixed-length hexadecimal string value from any file type or data. Let's look at an example. We have an image file that we can run through a hashing algorithm and get a hexadecimal output. This output is the hash. All hashing functions are one-way functions. This means that the hash cannot be reversed. In other words, you can't decipher a hash and find out what the original data was. A proper hash function has five characteristics. First, it should be deterministic, meaning the same data will always generate the same hash. Next, the hash generation needs to be quick and efficient, and it can't be reverse-engineered. The hash function should also be collision-resistant and exhibit the avalanche effect, meaning that that if even one tiny bit in the data is changed, the new hash will be completely different. For example, using the MD5 algorithm, the hash for the message 'Hello world\" would look like this. If we capitalize the W and generate a new hash using the same algorithm, we get a very different hash. There are a few reasons why you may want to generate a hash for some of your data, such as verifying file integrity, providing digital signatures, and verifying passwords. Let's look at each in more detail. We download files from the internet all the time. When you do this, you're not always sure that a file is safe and hasn't been tampered with. By providing a hash of the original file, you can verify that the file you downloaded is legitimate. For example, when an application developer finalizes their program, they can generate a hash of the app and the upload the app to their website along with the generated hash. Later, this company's website gets hacked, and the hacker replaces the program file with another malicious program by the same name. When a customer downloads the file, they can generate a hash and compare it to the original hash. Because the app file has been replaced, the hashes won't match, and they'll know that the file has been changed and they shouldn't run it. Hashing is also used when creating a digital signature for an important message. Using a hash of the data along with our private encryption key, a digital signature is created. This is the equivalent of signing our name to a physical document. When the recipient receives the message, they can verify the digital signature to ensure that the data or message is legitimate. Hashing is also used to protect passwords. Instead of sending the password in clear text, only a hash of the password is sent. For example, when you use a Microsoft account to sign in to a Windows system, your password is first encrypted using a special hashing algorithm called NTLM. That hash is then checked by Windows, and if it matches, you're signed in. One of the problems with using hashed passwords is that several online sites have collected massive databases containing a hash for tens of million of possible passwords. Once a hash has been captured, it can be compared with the hashes found in the database, quickly resulting in the password used to create the hash. To keep this from happening, most hashes now also incorporate what's known as a salt. Salting the hash means that a random number of characters are added to the password before the hash is created. For example, if the password to be hashed was this, a salt such as this may be added. The string to be hashed becomes this. Since the salt is randomly generated each time, even if the same password is used, and can be varying lengths, it's virtually impossible to create a database containing all the possible salted passwords. Using hashing helps meet the goals of Information Security by providing file integrity, non-repudiation, confidentiality, and authentication. Hashing is a very good file verification method, but it's not 100% foolproof. Depending on the algorithm used, there's a potential for hash collisions. A hash collision occurs when two completely different files generate the same hash. A rainbow table attack takes advantage of this weakness. Let's go through the process. A rainbow table is a table of passwords and their generated hashes. A hacker can use this table to match a captured hash with one in the table. When a match is found, the hacker knows the password, or in the case of a collision, they'll at least know a password that will work. For example, let's say a user's sign-in password is TestOut, which generates this hash. In the hacker's rainbow table, the password of SecurityPro has also generated the same hash value. This is a hash collision. Taking advantage of this collision, the hacker can gain access to the system using the password of SecurityPro, since it will send the same hash value that the real password uses. You can reduce the risk of a hash collision by using an algorithm that will generate a longer hash and by salting the hash. That's it for this lesson. We've discussed how hashing works, including the characteristics of a proper hash function. We reviewed some of the ways hashing is used, including verifying file integrity, digital signatures, and passwords. We ended by discussing hash collisions and how hackers can exploit them using rainbow tables.",
  "chunks": [
    {
      "chunk_id": "3.3.1_chunk_1",
      "content": "When you're transferring or downloading files, it's important to know that the file is legitimate and hasn't been altered in any way. This is what hashes are for. In this lesson, we'll discuss how hashing works, some common ways they're used, what hashing collisions are, and how to reduce collisions.",
      "summary": "Hashing provides cryptographic verification that files remain unaltered during transfer or download by generating unique digital fingerprints that detect unauthorized modifications. This security mechanism helps ensure file integrity and authenticity, with collision-resistant hash algorithms being essential to prevent different files from producing identical hash values that could compromise security validation.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Hashing",
      "timestamp_range": "00:00-00:20"
    },
    {
      "chunk_id": "3.3.1_chunk_2",
      "content": "Hashing is the process of generating a fixed-length hexadecimal string value from any file type or data. Let's look at an example. We have an image file that we can run through a hashing algorithm and get a hexadecimal output. This output is the hash. All hashing functions are one-way functions. This means that the hash cannot be reversed. In other words, you can't decipher a hash and find out what the original data was. A proper hash function has five characteristics. First, it should be deterministic, meaning the same data will always generate the same hash. Next, the hash generation needs to be quick and efficient, and it can't be reverse-engineered. The hash function should also be collision-resistant and exhibit the avalanche effect, meaning that that if even one tiny bit in the data is changed, the new hash will be completely different. For example, using the MD5 algorithm, the hash for the message 'Hello world\" would look like this. If we capitalize the W and generate a new hash using the same algorithm, we get a very different hash. There are a few reasons why you may want to generate a hash for some of your data, such as verifying file integrity, providing digital signatures, and verifying passwords. Let's look at each in more detail.",
      "summary": "Hashing is a one-way cryptographic process that generates fixed-length hexadecimal strings from any data input, where the same data always produces identical hashes but cannot be reversed to reveal original content. Proper hash functions must be deterministic, efficient, collision-resistant, and exhibit avalanche effect where minimal data changes create completely different hash outputs. Hashing serves critical security functions including file integrity verification, digital signatures, and password verification in cybersecurity implementations.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "How Hashes Work",
      "timestamp_range": "00:20-01:36"
    },
    {
      "chunk_id": "3.3.1_chunk_3",
      "content": "We download files from the internet all the time. When you do this, you're not always sure that a file is safe and hasn't been tampered with. By providing a hash of the original file, you can verify that the file you downloaded is legitimate. For example, when an application developer finalizes their program, they can generate a hash of the app and the upload the app to their website along with the generated hash. Later, this company's website gets hacked, and the hacker replaces the program file with another malicious program by the same name. When a customer downloads the file, they can generate a hash and compare it to the original hash. Because the app file has been replaced, the hashes won't match, and they'll know that the file has been changed and they shouldn't run it.",
      "summary": "Hash verification enables detection of file tampering by comparing a downloaded file's generated hash against the original hash provided by the developer. When files are compromised or replaced with malicious versions, the hash values will not match, indicating the file has been altered and should not be executed. This cryptographic integrity check protects against downloading corrupted or malicious files from potentially compromised websites.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Verifying File Integrity",
      "timestamp_range": "01:36-02:20"
    },
    {
      "chunk_id": "3.3.1_chunk_4",
      "content": "Hashing is also used when creating a digital signature for an important message. Using a hash of the data along with our private encryption key, a digital signature is created. This is the equivalent of signing our name to a physical document. When the recipient receives the message, they can verify the digital signature to ensure that the data or message is legitimate.",
      "summary": "Digital signatures use hashing combined with private encryption keys to authenticate message integrity and sender identity, functioning as the digital equivalent of a handwritten signature on physical documents. Recipients can verify digital signatures to confirm message legitimacy and detect tampering. This cryptographic process ensures non-repudiation and data authenticity in secure communications.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Digital Signatures",
      "timestamp_range": "02:20-02:41"
    },
    {
      "chunk_id": "3.3.1_chunk_5",
      "content": "Hashing is also used to protect passwords. Instead of sending the password in clear text, only a hash of the password is sent. For example, when you use a Microsoft account to sign in to a Windows system, your password is first encrypted using a special hashing algorithm called NTLM. That hash is then checked by Windows, and if it matches, you're signed in.",
      "summary": "Password hashing protects authentication by converting plaintext passwords into hash values that are transmitted and stored instead of the original password. When users authenticate, their entered password is hashed using algorithms like NTLM and compared against the stored hash for verification. This cryptographic technique prevents password exposure during transmission and storage while maintaining secure user authentication.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Password Verification",
      "timestamp_range": "02:41-03:04"
    },
    {
      "chunk_id": "3.3.1_chunk_6",
      "content": "One of the problems with using hashed passwords is that several online sites have collected massive databases containing a hash for tens of million of possible passwords. Once a hash has been captured, it can be compared with the hashes found in the database, quickly resulting in the password used to create the hash. To keep this from happening, most hashes now also incorporate what's known as a salt. Salting the hash means that a random number of characters are added to the password before the hash is created. For example, if the password to be hashed was this, a salt such as this may be added. The string to be hashed becomes this. Since the salt is randomly generated each time, even if the same password is used, and can be varying lengths, it's virtually impossible to create a database containing all the possible salted passwords. Using hashing helps meet the goals of Information Security by providing file integrity, non-repudiation, confidentiality, and authentication.",
      "summary": "Salting the hash involves adding random characters to passwords before hashing to prevent attackers from using precomputed hash databases (rainbow tables) to crack passwords. Since salts are randomly generated for each password and can vary in length, they make it virtually impossible to create comprehensive databases of salted password hashes. This technique enhances password security by ensuring that identical passwords produce different hash values, supporting information security goals of integrity, non-repudiation, confidentiality, and authentication.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Salting the Hash",
      "timestamp_range": "03:04-04:05"
    },
    {
      "chunk_id": "3.3.1_chunk_7",
      "content": "Hashing is a very good file verification method, but it's not 100% foolproof. Depending on the algorithm used, there's a potential for hash collisions. A hash collision occurs when two completely different files generate the same hash. A rainbow table attack takes advantage of this weakness. Let's go through the process. A rainbow table is a table of passwords and their generated hashes. A hacker can use this table to match a captured hash with one in the table. When a match is found, the hacker knows the password, or in the case of a collision, they'll at least know a password that will work. For example, let's say a user's sign-in password is TestOut, which generates this hash. In the hacker's rainbow table, the password of SecurityPro has also generated the same hash value. This is a hash collision. Taking advantage of this collision, the hacker can gain access to the system using the password of SecurityPro, since it will send the same hash value that the real password uses. You can reduce the risk of a hash collision by using an algorithm that will generate a longer hash and by salting the hash.",
      "summary": "Hash collisions occur when different inputs produce identical hash values, creating a security vulnerability that attackers exploit through rainbow table attacks to match captured hashes with pre-computed password tables. When a collision is found, hackers can use any password that generates the matching hash to gain unauthorized system access, even if it's not the original password. Organizations can mitigate hash collision risks by implementing longer hash algorithms and adding salt to hash functions.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Hash Collisions",
      "timestamp_range": "04:05-05:13"
    },
    {
      "chunk_id": "3.3.1_chunk_8",
      "content": "That's it for this lesson. We've discussed how hashing works, including the characteristics of a proper hash function. We reviewed some of the ways hashing is used, including verifying file integrity, digital signatures, and passwords. We ended by discussing hash collisions and how hackers can exploit them using rainbow tables.",
      "summary": "This lesson covered hashing fundamentals, including proper hash function characteristics and key security applications such as file integrity verification, digital signatures, and password storage. The content addressed hash collision vulnerabilities and how attackers exploit these weaknesses through rainbow table attacks to compromise hashed passwords.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Summary",
      "timestamp_range": "05:13-05:31"
    }
  ],
  "num_chunks": 8,
  "document_summary": "Hashing (video): Hashing is the process of generating a fixed-length hexadecimal string value from any file type or data. Using a hash of the data along with our private encryption key, a digital signature is created. Using hashing helps meet the goals of Information Security by providing file integrity, non-repudiation, confidentiality, and authentication."
}