{
  "metadata": {
    "chapter_num": "3",
    "section_num": "3.3.1",
    "title": "Hashing",
    "content_type": "video",
    "filename": "3.3.1_Hashing_[video].txt",
    "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
    "word_count": 981,
    "has_content": true
  },
  "full_content": "When you're transferring or downloading files, it's important to know that the file is legitimate and hasn't been altered in any way. This is what hashes are for. In this lesson, we'll discuss how hashing works, some common ways they're used, what hashing collisions are, and how to reduce collisions. Hashing is the process of generating a fixed-length hexadecimal string value from any file type or data. Let's look at an example. We have an image file that we can run through a hashing algorithm and get a hexadecimal output. This output is the hash. All hashing functions are one-way functions. This means that the hash cannot be reversed. In other words, you can't decipher a hash and find out what the original data was. A proper hash function has five characteristics. First, it should be deterministic, meaning the same data will always generate the same hash. Next, the hash generation needs to be quick and efficient, and it can't be reverse-engineered. The hash function should also be collision-resistant and exhibit the avalanche effect, meaning that that if even one tiny bit in the data is changed, the new hash will be completely different. For example, using the MD5 algorithm, the hash for the message 'Hello world\" would look like this. If we capitalize the W and generate a new hash using the same algorithm, we get a very different hash. There are a few reasons why you may want to generate a hash for some of your data, such as verifying file integrity, providing digital signatures, and verifying passwords. Let's look at each in more detail. We download files from the internet all the time. When you do this, you're not always sure that a file is safe and hasn't been tampered with. By providing a hash of the original file, you can verify that the file you downloaded is legitimate. For example, when an application developer finalizes their program, they can generate a hash of the app and the upload the app to their website along with the generated hash. Later, this company's website gets hacked, and the hacker replaces the program file with another malicious program by the same name. When a customer downloads the file, they can generate a hash and compare it to the original hash. Because the app file has been replaced, the hashes won't match, and they'll know that the file has been changed and they shouldn't run it. Hashing is also used when creating a digital signature for an important message. Using a hash of the data along with our private encryption key, a digital signature is created. This is the equivalent of signing our name to a physical document. When the recipient receives the message, they can verify the digital signature to ensure that the data or message is legitimate. Hashing is also used to protect passwords. Instead of sending the password in clear text, only a hash of the password is sent. For example, when you use a Microsoft account to sign in to a Windows system, your password is first encrypted using a special hashing algorithm called NTLM. That hash is then checked by Windows, and if it matches, you're signed in. One of the problems with using hashed passwords is that several online sites have collected massive databases containing a hash for tens of million of possible passwords. Once a hash has been captured, it can be compared with the hashes found in the database, quickly resulting in the password used to create the hash. To keep this from happening, most hashes now also incorporate what's known as a salt. Salting the hash means that a random number of characters are added to the password before the hash is created. For example, if the password to be hashed was this, a salt such as this may be added. The string to be hashed becomes this. Since the salt is randomly generated each time, even if the same password is used, and can be varying lengths, it's virtually impossible to create a database containing all the possible salted passwords. Using hashing helps meet the goals of Information Security by providing file integrity, non-repudiation, confidentiality, and authentication. Hashing is a very good file verification method, but it's not 100% foolproof. Depending on the algorithm used, there's a potential for hash collisions. A hash collision occurs when two completely different files generate the same hash. A rainbow table attack takes advantage of this weakness. Let's go through the process. A rainbow table is a table of passwords and their generated hashes. A hacker can use this table to match a captured hash with one in the table. When a match is found, the hacker knows the password, or in the case of a collision, they'll at least know a password that will work. For example, let's say a user's sign-in password is TestOut, which generates this hash. In the hacker's rainbow table, the password of SecurityPro has also generated the same hash value. This is a hash collision. Taking advantage of this collision, the hacker can gain access to the system using the password of SecurityPro, since it will send the same hash value that the real password uses. You can reduce the risk of a hash collision by using an algorithm that will generate a longer hash and by salting the hash. That's it for this lesson. We've discussed how hashing works, including the characteristics of a proper hash function. We reviewed some of the ways hashing is used, including verifying file integrity, digital signatures, and passwords. We ended by discussing hash collisions and how hackers can exploit them using rainbow tables.",
  "chunks": [
    {
      "chunk_id": "3.3.1_chunk_1",
      "content": "When you're transferring or downloading files, it's important to know that the file is legitimate and hasn't been altered in any way. This is what hashes are for. In this lesson, we'll discuss how hashing works, some common ways they're used, what hashing collisions are, and how to reduce collisions.",
      "summary": "Hashing: When you're transferring or downloading files, it's important to know that the file is legitimate and hasn't been altered in any way. In this lesson, we'll discuss how hashing works, some common ways they're used, what hashing collisions are, and how to reduce collisions.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Hashing",
      "timestamp_range": "00:00-00:20"
    },
    {
      "chunk_id": "3.3.1_chunk_2",
      "content": "Hashing is the process of generating a fixed-length hexadecimal string value from any file type or data. Let's look at an example. We have an image file that we can run through a hashing algorithm and get a hexadecimal output. This output is the hash. All hashing functions are one-way functions. This means that the hash cannot be reversed. In other words, you can't decipher a hash and find out what the original data was. A proper hash function has five characteristics. First, it should be deterministic, meaning the same data will always generate the same hash. Next, the hash generation needs to be quick and efficient, and it can't be reverse-engineered. The hash function should also be collision-resistant and exhibit the avalanche effect, meaning that that if even one tiny bit in the data is changed, the new hash will be completely different. For example, using the MD5 algorithm, the hash for the message 'Hello world\" would look like this. If we capitalize the W and generate a new hash using the same algorithm, we get a very different hash. There are a few reasons why you may want to generate a hash for some of your data, such as verifying file integrity, providing digital signatures, and verifying passwords. Let's look at each in more detail.",
      "summary": "How Hashes Work: Hashing is the process of generating a fixed-length hexadecimal string value from any file type or data. In other words, you can't decipher a hash and find out what the original data was.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "How Hashes Work",
      "timestamp_range": "00:20-01:36"
    },
    {
      "chunk_id": "3.3.1_chunk_3",
      "content": "We download files from the internet all the time. When you do this, you're not always sure that a file is safe and hasn't been tampered with. By providing a hash of the original file, you can verify that the file you downloaded is legitimate. For example, when an application developer finalizes their program, they can generate a hash of the app and the upload the app to their website along with the generated hash. Later, this company's website gets hacked, and the hacker replaces the program file with another malicious program by the same name. When a customer downloads the file, they can generate a hash and compare it to the original hash. Because the app file has been replaced, the hashes won't match, and they'll know that the file has been changed and they shouldn't run it.",
      "summary": "Verifying File Integrity: When you do this, you're not always sure that a file is safe and hasn't been tampered with. By providing a hash of the original file, you can verify that the file you downloaded is legitimate.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Verifying File Integrity",
      "timestamp_range": "01:36-02:20"
    },
    {
      "chunk_id": "3.3.1_chunk_4",
      "content": "Hashing is also used when creating a digital signature for an important message. Using a hash of the data along with our private encryption key, a digital signature is created. This is the equivalent of signing our name to a physical document. When the recipient receives the message, they can verify the digital signature to ensure that the data or message is legitimate.",
      "summary": "Digital Signatures: Using a hash of the data along with our private encryption key, a digital signature is created. When the recipient receives the message, they can verify the digital signature to ensure that the data or message is legitimate.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Digital Signatures",
      "timestamp_range": "02:20-02:41"
    },
    {
      "chunk_id": "3.3.1_chunk_5",
      "content": "Hashing is also used to protect passwords. Instead of sending the password in clear text, only a hash of the password is sent. For example, when you use a Microsoft account to sign in to a Windows system, your password is first encrypted using a special hashing algorithm called NTLM. That hash is then checked by Windows, and if it matches, you're signed in.",
      "summary": "Password Verification: Instead of sending the password in clear text, only a hash of the password is sent. For example, when you use a Microsoft account to sign in to a Windows system, your password is first encrypted using a special hashing algorithm called NTLM.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Password Verification",
      "timestamp_range": "02:41-03:04"
    },
    {
      "chunk_id": "3.3.1_chunk_6",
      "content": "One of the problems with using hashed passwords is that several online sites have collected massive databases containing a hash for tens of million of possible passwords. Once a hash has been captured, it can be compared with the hashes found in the database, quickly resulting in the password used to create the hash. To keep this from happening, most hashes now also incorporate what's known as a salt. Salting the hash means that a random number of characters are added to the password before the hash is created. For example, if the password to be hashed was this, a salt such as this may be added. The string to be hashed becomes this. Since the salt is randomly generated each time, even if the same password is used, and can be varying lengths, it's virtually impossible to create a database containing all the possible salted passwords. Using hashing helps meet the goals of Information Security by providing file integrity, non-repudiation, confidentiality, and authentication.",
      "summary": "Salting the Hash: One of the problems with using hashed passwords is that several online sites have collected massive databases containing a hash for tens of million of possible passwords. Using hashing helps meet the goals of Information Security by providing file integrity, non-repudiation, confidentiality, and authentication.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Salting the Hash",
      "timestamp_range": "03:04-04:05"
    },
    {
      "chunk_id": "3.3.1_chunk_7",
      "content": "Hashing is a very good file verification method, but it's not 100% foolproof. Depending on the algorithm used, there's a potential for hash collisions. A hash collision occurs when two completely different files generate the same hash. A rainbow table attack takes advantage of this weakness. Let's go through the process. A rainbow table is a table of passwords and their generated hashes. A hacker can use this table to match a captured hash with one in the table. When a match is found, the hacker knows the password, or in the case of a collision, they'll at least know a password that will work. For example, let's say a user's sign-in password is TestOut, which generates this hash. In the hacker's rainbow table, the password of SecurityPro has also generated the same hash value. This is a hash collision. Taking advantage of this collision, the hacker can gain access to the system using the password of SecurityPro, since it will send the same hash value that the real password uses. You can reduce the risk of a hash collision by using an algorithm that will generate a longer hash and by salting the hash.",
      "summary": "Hash Collisions: In the hacker's rainbow table, the password of SecurityPro has also generated the same hash value. Taking advantage of this collision, the hacker can gain access to the system using the password of SecurityPro, since it will send the same hash value that the real password uses.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Hash Collisions",
      "timestamp_range": "04:05-05:13"
    },
    {
      "chunk_id": "3.3.1_chunk_8",
      "content": "That's it for this lesson. We've discussed how hashing works, including the characteristics of a proper hash function. We reviewed some of the ways hashing is used, including verifying file integrity, digital signatures, and passwords. We ended by discussing hash collisions and how hackers can exploit them using rainbow tables.",
      "summary": "We've discussed how hashing works, including the characteristics of a proper hash function. We reviewed some of the ways hashing is used, including verifying file integrity, digital signatures, and passwords.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.1",
        "title": "Hashing",
        "content_type": "video",
        "filename": "3.3.1_Hashing_[video].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.1_Hashing_[video].txt",
        "word_count": 981,
        "has_content": true
      },
      "section_header": "Summary",
      "timestamp_range": "05:13-05:31"
    }
  ],
  "num_chunks": 8,
  "document_summary": "Hashing (video): Hashing is the process of generating a fixed-length hexadecimal string value from any file type or data. Using a hash of the data along with our private encryption key, a digital signature is created. Using hashing helps meet the goals of Information Security by providing file integrity, non-repudiation, confidentiality, and authentication."
}