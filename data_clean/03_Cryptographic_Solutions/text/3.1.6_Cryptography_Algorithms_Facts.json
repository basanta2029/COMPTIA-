{
  "metadata": {
    "chapter_num": "3",
    "section_num": "3.1.6",
    "title": "Cryptography Algorithms Facts",
    "content_type": "text",
    "filename": "3.1.6_Cryptography_Algorithms_Facts_[text].txt",
    "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.6_Cryptography_Algorithms_Facts_[text].txt",
    "word_count": 1174,
    "has_content": true
  },
  "full_content": "Security Pro 8.0 The cornerstone of all cryptography is the algorithm or cipher. There are different types of ciphers in use today. Stream cipher Block cipher Lightweight cryptography Homomorphic encryption Stream Cipher A stream cipher is a symmetric encryption method that encrypts data one bit at a time. The stream cipher is based on the one-time pad (OTP) concept used extensively during World War 2. Consider the following OTP characteristics: The OTP uses a symmetric encryption key the same length as the data being encrypted. The encryption key is used to encrypt the data using a process called XORing. This means that two binary strings are compared. If the bits match, a zero is generated. If the bits do not match, a one is generated. The output of the XOR process is the ciphertext. The OTP demonstrates what is called perfect secrecy. This means that it is just as, if not more, difficult for a hacker to brute-force the key as it would be to brute-force the data itself. The OTP only provides perfect secrecy if the secret key is only used once. If used more than once, a hacker could begin to decode it. OTP works well when dealing with small messages, but it becomes impractical when dealing with large data due to the keys being so extensive. A stream cipher solves the problem of having excessively large keys associated with OTP by using a smaller, fixed-length seed key, such as one that is 2048 bits in length. The following describes the process of creating a seed key: The seed key is run through a pseudorandom number generator, which outputs a new and unique encryption key the same size as the data being encrypted. This new key is called a keystream. The keystream is XORed with the data to create the ciphertext. The seed key can be used repeatedly throughout the encryption process. While stream ciphers are less secure than the one-time pad, this method can be used in real-time. One of the most widely used stream ciphers was Rivest's Cipher 4 (RC4). However, multiple vulnerabilities have been discovered in RC4, rendering it insecure. It is no longer used today. Block Cipher Many symmetric encryption algorithms use the block cipher method. Instead of encrypting our data one bit at a time, a block cipher encrypts the data one chunk at a time. Common block sizes are 64, 128, or 256 bits in length. For example, when encrypting a piece of data that is 100 bytes in size using a 256-bit block size, the data would be encrypted 32 bytes at a time (256 bits/8 = 32 bytes). Because the last block is less than 32 bytes, extra random bits are added to bring the block up to 32 bytes. There are six block cipher modes of operation that can be utilized depending on the application or use: Mode of Operation Description Electronic Code Book (ECB) ECB is the simplest mode of operation. Each block of plaintext data is encrypted separately. Blocks of data can be encrypted simultaneously, allowing for faster encryption. The biggest disadvantage is that blocks with identical data will generate the same ciphertext. Cipher Block Chaining (CBC) CBC is similar to ECB, except this mode uses an initialization vector (IV). The IV is a starting variable that is XORed with the plaintext of the current block to encrypt the data. The IV for the starting block is a randomly generated value. Each subsequent IV is the ciphertext from the previous block. CBC is more secure than ECB due to the IV, but it is slower because blocks cannot be encrypted simultaneously. Cipher Feedback mode (CFB) CFB also uses an IV, but instead of using it on the plaintext, the IV is encrypted first. That output is then XORed with the plaintext to create the block of ciphertext. This is the equivalent of using a one-time pad to encrypt the data. The IV for the starting block is a randomly generated value. Each subsequent IV is the ciphertext from the previous block. Output Feedback mode (OFB) This mode is identical to CFB except for the IV used after the first round. The output of the IV encryption is used as the next block's ciphertext. Counter mode (CTR) Instead of using an initialization vector, CTR uses a nonce combined with a counter that is encrypted. A nonce is a random string used for all blocks during the encryption process. The encrypted output of the nonce and counter is then XORed with the plaintext to create the ciphertext. The counter increments for each block. This ensures that each block uses a different value so that even if blocks have the same data, the ciphertext will be different. Galois Counter mode (GCM) All other modes of operation are unauthenticated forms of encryption. The Galois Counter mode provides both encryption and authentication. GCM works like Counter mode, except the ciphertext is combined with a special hash. The output of the ciphertext and hash contains the encrypted data and a Message Authentication Code (MAC) that gives assurance that the message has not been tampered with. Because GCM is extremely efficient and provides authentication, it is often used with network communications such as 802.11 and when sending encrypted data to a web server using TLS or SSH. There are other encryption methods that also provide authentication, but GCM is the most widely used method. Lightweight Cryptography In 2018, NIST began the process to standardize encryption algorithms called lightweight cryptography. Lightweight cryptography is meant to be used on Internet of Things (IoT) devices. Many IoT devices are small, low-powered devices that do not have the resources to handle other encryption methods. Some of the limitations of IoT devices that lightweight cryptography needs to address are: Small amount of RAM Low CPU power Low-powered or runs on batteries Lightweight cryptography algorithms need to work on these devices efficiently while still providing high levels of security. Homomorphic Encryption An inherent risk with all encryption is that for the data to be worked on (computation on ciphertexts), it must first be decrypted. Homomorphic encryption addresses this concern by allowing data to be worked on without decrypting it first. There are three types of homomorphic encryption. To explain the differences, it works best to think of data as integers and to use math functions to represent the manipulation of that data. Homomorphic Encryption Type Description Partially homomorphic encryption (PHE)\tPHE allows only select simple math functions (such as addition) to be performed. This means that only one math function can be performed an unlimited number of times on the encrypted values. Somewhat homomorphic encryption (SHE)\tSHE allows more complex math (such as multiplication) to occur. However, it can only be performed a limited number of times. Fully homomorphic encryption (FHE) This method can handle both simple and advanced math functions (such as addition and multiplication) being performed an unlimited number of times on the encrypted values. FHE is still in the developmental stage.",
  "chunks": [
    {
      "chunk_id": "3.1.6_chunk_1",
      "content": "Security Pro 8.0",
      "summary": "The CompTIA Security+ course, Security Pro 8.0, introduces foundational cybersecurity concepts, emphasizing the importance of securing networks, systems, and data against various threats. Key topics include risk management, cryptography, identity and access management, and incident response, providing learners with practical skills to implement security measures effectively. This course prepares participants for real-world applications and challenges in the cybersecurity landscape.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.6",
        "title": "Cryptography Algorithms Facts",
        "content_type": "text",
        "filename": "3.1.6_Cryptography_Algorithms_Facts_[text].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.6_Cryptography_Algorithms_Facts_[text].txt",
        "word_count": 1174,
        "has_content": true
      },
      "section_header": "Introduction",
      "timestamp_range": null
    },
    {
      "chunk_id": "3.1.6_chunk_2",
      "content": "The cornerstone of all cryptography is the algorithm or cipher. There are different types of ciphers in use today.",
      "summary": "Cryptography relies on algorithms, or ciphers, which are essential for securing data through encryption and decryption processes. Various types of ciphers, including symmetric and asymmetric algorithms, serve distinct purposes in protecting information confidentiality, integrity, and authenticity. Understanding these algorithms is crucial for implementing effective security measures in various applications, from secure communications to data protection.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.6",
        "title": "Cryptography Algorithms Facts",
        "content_type": "text",
        "filename": "3.1.6_Cryptography_Algorithms_Facts_[text].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.6_Cryptography_Algorithms_Facts_[text].txt",
        "word_count": 1174,
        "has_content": true
      },
      "section_header": "3.1.6 Cryptography Algorithms Facts",
      "timestamp_range": null
    },
    {
      "chunk_id": "3.1.6_chunk_3",
      "content": "Stream cipher Block cipher Lightweight cryptography Homomorphic encryption Stream Cipher A stream cipher is a symmetric encryption method that encrypts data one bit at a time. The stream cipher is based on the one-time pad (OTP) concept used extensively during World War 2. Consider the following OTP characteristics: The OTP uses a symmetric encryption key the same length as the data being encrypted. The encryption key is used to encrypt the data using a process called XORing. This means that two binary strings are compared. If the bits match, a zero is generated. If the bits do not match, a one is generated. The output of the XOR process is the ciphertext. The OTP demonstrates what is called perfect secrecy. This means that it is just as, if not more, difficult for a hacker to brute-force the key as it would be to brute-force the data itself. The OTP only provides perfect secrecy if the secret key is only used once. If used more than once, a hacker could begin to decode it. OTP works well when dealing with small messages, but it becomes impractical when dealing with large data due to the keys being so extensive. A stream cipher solves the problem of having excessively large keys associated with OTP by using a smaller, fixed-length seed key, such as one that is 2048 bits in length. The following describes the process of creating a seed key: The seed key is run through a pseudorandom number generator, which outputs a new and unique encryption key the same size as the data being encrypted. This new key is called a keystream. The keystream is XORed with the data to create the ciphertext. The seed key can be used repeatedly throughout the encryption process. While stream ciphers are less secure than the one-time pad, this method can be used in real-time. One of the most widely used stream ciphers was Rivest's Cipher 4 (RC4). However, multiple vulnerabilities have been discovered in RC4, rendering it insecure. It is no longer used today. Block Cipher Many symmetric encryption algorithms use the block cipher method. Instead of encrypting our data one bit at a time, a block cipher encrypts the data one chunk at a time. Common block sizes are 64, 128, or 256 bits in length. For example, when encrypting a piece of data that is 100 bytes in size using a 256-bit block size, the data would be encrypted 32 bytes at a time (256 bits/8 = 32 bytes). Because the last block is less than 32 bytes, extra random bits are added to bring the block up to 32 bytes. There are six block cipher modes of operation that can be utilized depending on the application or use: Mode of Operation Description Electronic Code Book (ECB) ECB is the simplest mode of operation. Each block of plaintext data is encrypted separately. Blocks of data can be encrypted simultaneously, allowing for faster encryption. The biggest disadvantage is that blocks with identical data will generate the same ciphertext. Cipher Block Chaining (CBC) CBC is similar to ECB, except this mode uses an initialization vector (IV). The IV is a starting variable that is XORed with the plaintext of the current block to encrypt the data. The IV for the starting block is a randomly generated value. Each subsequent IV is the ciphertext from the previous block. CBC is more secure than ECB due to the IV, but it is slower because blocks cannot be encrypted simultaneously. Cipher Feedback mode (CFB) CFB also uses an IV, but instead of using it on the plaintext, the IV is encrypted first. That output is then XORed with the plaintext to create the block of ciphertext. This is the equivalent of using a one-time pad to encrypt the data. The IV for the starting block is a randomly generated value. Each subsequent IV is the ciphertext from the previous block. Output Feedback mode (OFB) This mode is identical to CFB except for the IV used after the first round. The output of the IV encryption is used as the next block's ciphertext. Counter mode (CTR) Instead of using an initialization vector, CTR uses a nonce combined with a counter that is encrypted. A nonce is a random string used for all blocks during the encryption process. The encrypted output of the nonce and counter is then XORed with the plaintext to create the ciphertext. The counter increments for each block. This ensures that each block uses a different value so that even if blocks have the same data, the ciphertext will be different. Galois Counter mode (GCM) All other modes of operation are unauthenticated forms of encryption. The Galois Counter mode provides both encryption and authentication. GCM works like Counter mode, except the ciphertext is combined with a special hash. The output of the ciphertext and hash contains the encrypted data and a Message Authentication Code (MAC) that gives assurance that the message has not been tampered with. Because GCM is extremely efficient and provides authentication, it is often used with network communications such as 802.11 and when sending encrypted data to a web server using TLS or SSH. There are other encryption methods that also provide authentication, but GCM is the most widely used method. Lightweight Cryptography In 2018, NIST began the process to standardize encryption algorithms called lightweight cryptography. Lightweight cryptography is meant to be used on Internet of Things (IoT) devices. Many IoT devices are small, low-powered devices that do not have the resources to handle other encryption methods. Some of the limitations of IoT devices that lightweight cryptography needs to address are: Small amount of RAM Low CPU power Low-powered or runs on batteries Lightweight cryptography algorithms need to work on these devices efficiently while still providing high levels of security. Homomorphic Encryption An inherent risk with all encryption is that for the data to be worked on (computation on ciphertexts), it must first be decrypted. Homomorphic encryption addresses this concern by allowing data to be worked on without decrypting it first. There are three types of homomorphic encryption. To explain the differences, it works best to think of data as integers and to use math functions to represent the manipulation of that data. Homomorphic Encryption Type Description Partially homomorphic encryption (PHE)\tPHE allows only select simple math functions (such as addition) to be performed. This means that only one math function can be performed an unlimited number of times on the encrypted values. Somewhat homomorphic encryption (SHE)\tSHE allows more complex math (such as multiplication) to occur. However, it can only be performed a limited number of times. Fully homomorphic encryption (FHE) This method can handle both simple and advanced math functions (such as addition and multiplication) being performed an unlimited number of times on the encrypted values. FHE is still in the developmental stage.",
      "summary": "This lesson covers key encryption methods, including stream ciphers and block ciphers, highlighting their operational mechanisms and security implications. Stream ciphers encrypt data bit by bit using a keystream generated from a seed key, while block ciphers process data in fixed-size chunks with various modes of operation, such as ECB and CBC, each offering different security features. Additionally, the lesson introduces lightweight cryptography for IoT devices and homomorphic encryption, which allows computations on encrypted data without decryption, enhancing data security in various applications.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.1.6",
        "title": "Cryptography Algorithms Facts",
        "content_type": "text",
        "filename": "3.1.6_Cryptography_Algorithms_Facts_[text].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.1.6_Cryptography_Algorithms_Facts_[text].txt",
        "word_count": 1174,
        "has_content": true
      },
      "section_header": "This lesson covers the following topics:",
      "timestamp_range": null
    }
  ],
  "num_chunks": 3
}