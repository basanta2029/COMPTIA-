{
  "metadata": {
    "chapter_num": "3",
    "section_num": "3.3.3",
    "title": "Hashing Facts",
    "content_type": "text",
    "filename": "3.3.3_Hashing_Facts_[text].txt",
    "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.3_Hashing_Facts_[text].txt",
    "word_count": 2064,
    "has_content": true
  },
  "full_content": "Security Pro 8.0 This lesson covers the following topics: Hashing Salting and key stretching Hashing uses Hash collisions Hashing algorithms Comparing hash values Hashing A cryptographic hashing algorithm produces a fixed-length string of bits from an input plaintext that can be of any length. The output can be referred to as a hash or message digest. The function is designed so that it is impossible to recover the plaintext data from the digest (one-way) and that different inputs are unlikely to produce the same output (a collision). A hashing algorithm is used to prove integrity. For example, Bob and Alice can compare the values used for a password in the following way: Bob has a digest calculated from Alice's plaintext password. Bob cannot recover the plaintext password value from the hash. When Alice needs to authenticate to Bob, they type their password, convert it to a hash, and send the digest to Bob. Bob compares Alice's digest to the hash value on file. If they match, Bob can be sure that Alice typed the same password. As well as comparing password values, a hash of a file can be used to verify the integrity of that file after transfer. Alice runs a hash function on the setup.exe file for their product. They publish the digest on their website with a download link for the file. Bob downloads the setup.exe file and makes a copy of the digest. Bob runs the same hash function on the downloaded setup.exe file and compares it to the reference value published by Alice. If it matches the value published on the website, Bob assumes the file has integrity. Consider that Mallory might be able to substitute the download file for a malicious file. Mallory cannot change the reference hash, however. This time, Bob computes a hash that does not match, leading him to suspect that the file has been tampered with. Confirming a file download using cryptographic hashes Description A single hash function, symmetric cipher, or asymmetric cipher is called a cryptographic primitive. A complete cryptographic system or product is likely to use multiple cryptographic primitives within a cipher suite. The properties of different symmetric/asymmetric/hash types and specific ciphers for each type impose limitations on their use in different contexts and for different purposes. Encryption can be used to ensure confidentiality. Cryptographic ciphers can also be used for integrity and authentication. If you can encode a message in a way that no one else can replicate, then the recipient of the message knows with whom they are communicating (that is, the sender is authenticated). Cryptography allows subjects to identify and authenticate themselves. Description Public key cryptography can authenticate a sender because they control a private key that produces messages in a way that no one else can. Hashing proves integrity by computing a unique fixed-size message digest from any variable length input. These two cryptographic ciphers can be combined to make a digital signature: The sender (Alice) creates a digest of a message using a pre-agreed hash algorithm, such as SHA256, and then performs a signing operation on the digest using her chosen asymmetric cipher and private key. Alice attaches the digital signature to the message and sends both the signature and the message to Bob. Bob verifies the signature using Alice's public key, obtaining the original hash. Bob then calculates his own digest for the document (using the same algorithm as Alice) and compares it with Alice's hash. If the two digests are the same, then the data has not been tampered with during transmission, and Alice's identity is guaranteed. If the data had changed or a malicious user (Mallory) had intercepted the message and used a different private key to sign it, the hashes would not match. Message authentication and integrity using digital signatures Images © 123RF.com Description There are several standards for creating digital signatures. The Public Key Cryptography Standard #1 (PKCS#1) defines the use of RSA's algorithm. The Digital Signature Algorithm (DSA) uses a cipher called ElGamal, but the Elliptic Curve DSA (ECDSA) is now more widely used. DSA and ECDSA were developed as part of the US government's Federal Information Processing Standards (FIPS). Salting and Key Stretching The values used for a private or secret key must be selected at random. If there is something predictable about the way the value of the key was derived, it has less entropy. Low entropy is a particular concern whenever a cryptographic system makes use of user-generated data, such as a password. Users tend to select low entropy passwords because they are easier to remember. This type of data is too short and ordered to be a good \"seed\" for key generation. Salting and key stretching help to protect password-derived cryptographic secrets from discovery through cryptanalysis. Salting Cryptographic hash functions are often used for password storage and transmission. A hash cannot be decrypted back to the plaintext password that generated it. Hash functions are one way. However, passwords stored as hashes are vulnerable to brute force and dictionary attacks. A threat actor can generate hashes to find a match for a hash captured from network traffic or a password file. A brute force attack simply runs through every possible combination of letters, numbers, and symbols. A dictionary attack creates hashes of common words and phrases. Both these attacks can be slowed down by adding a  salt value when creating the hash. A salted hash is computed as follows: (salt + password) * SHA = hash A unique, random salt value should be generated for each user account. This mitigates the risk that if users choose identical plaintext passwords, there would be identical hash values in the password file. The salt is not kept secret because any system verifying the hash must know the value of the salt. It simply means that an attacker cannot use precomputed tables of hashes. The hash values must be recompiled with the specific salt value for each password. Key Stretching Key stretching takes a key generated from a user password plus a random salt value and repeatedly converts it to a longer and more disordered key. The initial key may be put through thousands of rounds of hashing. This might not be difficult for the attacker to replicate, so it does not actually make the key stronger. It does slow the attack down because the attacker has to do extra processing for each possible key value. Key stretching can be performed using a particular software library to hash and save passwords when created. The Password-Based Key Derivation Function 2 (PBKDF2) is widely used for this purpose, notably as part of Wi-Fi Protected Access (WPA). Hashing Uses Hash Use Description File integrity Hashes are often used to prove the integrity of downloaded files. When a file is uploaded to a site, a hash can be generated. When the recipient downloads the file, they can create a hash of that file. If the recipient's hash matches the hash of the original file, you know that: The downloaded file is complete (no missing parts). The downloaded file was not corrupted during the transfer. The downloaded file is the same as the original and has not been altered by inserting malicious code or replaced with a virus or malware file. For this reason, files available for download are typically not encrypted, as the hash proves their data integrity. Digital signatures A digital signature is a combination of asymmetric encryption and hashing values. A signature provides confidentiality, integrity validation, strong authentication, and non-repudiation. Typically, a digital signature works as follows: A hash value is generated for a message. The hash value is asymmetrically encrypted using the sender's private key. Non-repudiation is provided because only the sender could have encrypted the hash using the private key (only the sender knows the private key). The encrypted hash value and the message are sent. The recipient decrypts the hash using the sender's public key. The recipient hashes the message. Message integrity and sender authenticity (non-repudiation) are confirmed if the two hash values match. Secure logon credential exchange Hashes can be used to secure logon credentials during an exchange. The password is used as the key to perform a hash on a text value, and only the hashed value is passed (not the password). The receiving host uses the same method to compare the hashes to verify the identity of the user. Examples of protocols that use this method are: Challenge-Handshake Authentication Protocol (CHAP) New Technology LAN Manager (NTLM) Kerberos Passwords can be further secured by salting the hash. This is the process of adding random characters at the beginning or end of the password to generate a completely different hash. If a hacker intercepts the hash, they must also know which portion is the salt before beginning to crack the hash. Hash Collisions Hashing is a good file verification method, but it is not perfect. Depending on the algorithm used, there is a potential for hash collisions. A hash collision occurs when two completely different files generate the same hash. Rainbow table attacks take advantage of hash collisions. A rainbow table is a table of passwords and their generated hashes. A hacker can use this table to try to match hashes instead of the actual password. Hash collisions can be reduced using an algorithm that generates a longer hash and by salting the hash. Salt is random data used as an additional input to the function that hashes data. Hashing Algorithms The two most popular implementations of hash algorithms are the Secure Hash Algorithm (SHA) and Message-Digest Algorithm #5 (MD5). Depending on the use, there are different hashing algorithms which can be used. The following table covers some of the more common algorithms. Hashing Algorithm Description Secure Hash Algorithm (SHA) SHA is a family of hashes. SHA is a government standard and is considered the strongest algorithm. First published in 1991 by the National Institute of Standards and Technology (NIST). SHA-2 was published in 2001 and has become one of the standard hash functions used today. Used in many security protocols such as TLS, SSL, PGP, SSH, and IPSec. Generates message digests that are 224, 256, 384, or 512 bits in size. The longer digests are considered more secure, with the most popular variant being SHA256, which produces a 256-bit digest. SHA-3 was published in 2015 but is not meant to replace SHA-2. SHA-2 has yet to be cracked. NIST wanted an alternative available for people to use. Message digests generated by SHA-3 are fully compatible with SHA-2. Computing an SHA value from a file Screenshot used with permission from Microsoft Description Message-Digest Algorithm 5 (MD5) MD5 was developed by Ron Rivest in 1991. MD5 generates a 128-bit message digest. Many security vulnerabilities have been discovered with MD5. As such, it is no longer viable for security purposes. MD5 is extremely susceptible to hash collisions. MD5 is mainly used for file integrity. MD5 is not considered safe for use, but it might be required for compatibility between security products. Hash-Based Message Authentication Code (HMAC) HMAC is a type of message authentication code. Like a digital signature, HMAC allows a user to verify that a file or message is legitimate. The message sender provides a secret key that is used with a hash function, such as MD5 or SHA, to create a message authentication code. The recipient then uses the key to verify both the integrity and authenticity of the message. RACE Integrity Primitives Evaluation Message Digest (RIPEMD) RIPEMD (RACE Integrity Primitives Evaluation Message Digest, or RIPE Message Digest) is a family of cryptographic hash functions that was first developed in 1992 as part of the EU's RIPE project. The first version was based on the MD4 function. In 1996, in response to security issues discovered in the first version, Belgian researchers developed four updated algorithms. RIPEMD-160 RIPEMD-320 RIPEMD is not as popular as SHA-2 but is used frequently with Bitcoin and other cryptocurrencies. Comparing Hash Values Being able to compare the hash of a file after it has been downloaded to a known good hash helps verify that the file was not altered in transit. Get-FileHash Get-FileHash Download.zip -a md5 Sample output from Get-FileHash Description Get-Content Get-Content Download.txt -eq \"39C784349F4ZDB44A84C7958C246E394\" -eq \"4A84C7958C246E39439C784349F4ZDB4\" The output will be \"True\" if the hashes match or \"False\" if they do not match.",
  "chunks": [
    {
      "chunk_id": "3.3.3_chunk_1",
      "content": "Security Pro 8.0",
      "summary": "Hashing is a cryptographic process that converts input data of any size into a fixed-length string called a hash digest or message digest, providing data integrity verification and authentication. Hash functions are one-way mathematical algorithms that produce unique fingerprints for data, making it computationally infeasible to reverse the process or find two inputs that produce the same hash value. Common hashing algorithms include MD5, SHA-1, SHA-256, and SHA-3, with stronger algorithms like SHA-256 recommended for security applications due to collision resistance and cryptographic strength.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.3",
        "title": "Hashing Facts",
        "content_type": "text",
        "filename": "3.3.3_Hashing_Facts_[text].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.3_Hashing_Facts_[text].txt",
        "word_count": 2064,
        "has_content": true
      },
      "section_header": "Introduction",
      "timestamp_range": null
    },
    {
      "chunk_id": "3.3.3_chunk_2",
      "content": "This lesson covers the following topics: Hashing Salting and key stretching Hashing uses Hash collisions Hashing algorithms Comparing hash values Hashing A cryptographic hashing algorithm produces a fixed-length string of bits from an input plaintext that can be of any length. The output can be referred to as a hash or message digest. The function is designed so that it is impossible to recover the plaintext data from the digest (one-way) and that different inputs are unlikely to produce the same output (a collision). A hashing algorithm is used to prove integrity. For example, Bob and Alice can compare the values used for a password in the following way: Bob has a digest calculated from Alice's plaintext password. Bob cannot recover the plaintext password value from the hash. When Alice needs to authenticate to Bob, they type their password, convert it to a hash, and send the digest to Bob. Bob compares Alice's digest to the hash value on file. If they match, Bob can be sure that Alice typed the same password. As well as comparing password values, a hash of a file can be used to verify the integrity of that file after transfer. Alice runs a hash function on the setup.exe file for their product. They publish the digest on their website with a download link for the file. Bob downloads the setup.exe file and makes a copy of the digest. Bob runs the same hash function on the downloaded setup.exe file and compares it to the reference value published by Alice. If it matches the value published on the website, Bob assumes the file has integrity. Consider that Mallory might be able to substitute the download file for a malicious file. Mallory cannot change the reference hash, however. This time, Bob computes a hash that does not match, leading him to suspect that the file has been tampered with. Confirming a file download using cryptographic hashes Description A single hash function, symmetric cipher, or asymmetric cipher is called a cryptographic primitive. A complete cryptographic system or product is likely to use multiple cryptographic primitives within a cipher suite. The properties of different symmetric/asymmetric/hash types and specific ciphers for each type impose limitations on their use in different contexts and for different purposes. Encryption can be used to ensure confidentiality. Cryptographic ciphers can also be used for integrity and authentication. If you can encode a message in a way that no one else can replicate, then the recipient of the message knows with whom they are communicating (that is, the sender is authenticated). Cryptography allows subjects to identify and authenticate themselves. Description Public key cryptography can authenticate a sender because they control a private key that produces messages in a way that no one else can. Hashing proves integrity by computing a unique fixed-size message digest from any variable length input. These two cryptographic ciphers can be combined to make a digital signature: The sender (Alice) creates a digest of a message using a pre-agreed hash algorithm, such as SHA256, and then performs a signing operation on the digest using her chosen asymmetric cipher and private key. Alice attaches the digital signature to the message and sends both the signature and the message to Bob. Bob verifies the signature using Alice's public key, obtaining the original hash. Bob then calculates his own digest for the document (using the same algorithm as Alice) and compares it with Alice's hash. If the two digests are the same, then the data has not been tampered with during transmission, and Alice's identity is guaranteed. If the data had changed or a malicious user (Mallory) had intercepted the message and used a different private key to sign it, the hashes would not match. Message authentication and integrity using digital signatures Images © 123RF.com Description There are several standards for creating digital signatures. The Public Key Cryptography Standard #1 (PKCS#1) defines the use of RSA's algorithm. The Digital Signature Algorithm (DSA) uses a cipher called ElGamal, but the Elliptic Curve DSA (ECDSA) is now more widely used. DSA and ECDSA were developed as part of the US government's Federal Information Processing Standards (FIPS). Salting and Key Stretching The values used for a private or secret key must be selected at random. If there is something predictable about the way the value of the key was derived, it has less entropy. Low entropy is a particular concern whenever a cryptographic system makes use of user-generated data, such as a password. Users tend to select low entropy passwords because they are easier to remember. This type of data is too short and ordered to be a good \"seed\" for key generation. Salting and key stretching help to protect password-derived cryptographic secrets from discovery through cryptanalysis. Salting Cryptographic hash functions are often used for password storage and transmission. A hash cannot be decrypted back to the plaintext password that generated it. Hash functions are one way. However, passwords stored as hashes are vulnerable to brute force and dictionary attacks. A threat actor can generate hashes to find a match for a hash captured from network traffic or a password file. A brute force attack simply runs through every possible combination of letters, numbers, and symbols. A dictionary attack creates hashes of common words and phrases. Both these attacks can be slowed down by adding a  salt value when creating the hash. A salted hash is computed as follows: (salt + password) * SHA = hash A unique, random salt value should be generated for each user account. This mitigates the risk that if users choose identical plaintext passwords, there would be identical hash values in the password file. The salt is not kept secret because any system verifying the hash must know the value of the salt. It simply means that an attacker cannot use precomputed tables of hashes. The hash values must be recompiled with the specific salt value for each password. Key Stretching Key stretching takes a key generated from a user password plus a random salt value and repeatedly converts it to a longer and more disordered key. The initial key may be put through thousands of rounds of hashing. This might not be difficult for the attacker to replicate, so it does not actually make the key stronger. It does slow the attack down because the attacker has to do extra processing for each possible key value. Key stretching can be performed using a particular software library to hash and save passwords when created. The Password-Based Key Derivation Function 2 (PBKDF2) is widely used for this purpose, notably as part of Wi-Fi Protected Access (WPA). Hashing Uses",
      "summary": "Cryptographic hashing algorithms produce fixed-length message digests from variable-length inputs to verify data integrity and authenticate users through one-way functions that cannot be reversed to recover plaintext. Salting adds random values to passwords before hashing to prevent dictionary attacks, while key stretching repeatedly hashes passwords through thousands of rounds to slow brute force attacks. Digital signatures combine hashing with asymmetric encryption to provide both message integrity verification and sender authentication by encrypting the hash digest with a private key.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.3",
        "title": "Hashing Facts",
        "content_type": "text",
        "filename": "3.3.3_Hashing_Facts_[text].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.3_Hashing_Facts_[text].txt",
        "word_count": 2064,
        "has_content": true
      },
      "section_header": "3.3.3 Hashing Facts",
      "timestamp_range": null
    },
    {
      "chunk_id": "3.3.3_chunk_3",
      "content": "Hash Use Description File integrity Hashes are often used to prove the integrity of downloaded files. When a file is uploaded to a site, a hash can be generated. When the recipient downloads the file, they can create a hash of that file. If the recipient's hash matches the hash of the original file, you know that: The downloaded file is complete (no missing parts). The downloaded file was not corrupted during the transfer. The downloaded file is the same as the original and has not been altered by inserting malicious code or replaced with a virus or malware file. For this reason, files available for download are typically not encrypted, as the hash proves their data integrity. Digital signatures A digital signature is a combination of asymmetric encryption and hashing values. A signature provides confidentiality, integrity validation, strong authentication, and non-repudiation. Typically, a digital signature works as follows: A hash value is generated for a message. The hash value is asymmetrically encrypted using the sender's private key. Non-repudiation is provided because only the sender could have encrypted the hash using the private key (only the sender knows the private key). The encrypted hash value and the message are sent. The recipient decrypts the hash using the sender's public key. The recipient hashes the message. Message integrity and sender authenticity (non-repudiation) are confirmed if the two hash values match. Secure logon credential exchange Hashes can be used to secure logon credentials during an exchange. The password is used as the key to perform a hash on a text value, and only the hashed value is passed (not the password). The receiving host uses the same method to compare the hashes to verify the identity of the user. Examples of protocols that use this method are: Challenge-Handshake Authentication Protocol (CHAP) New Technology LAN Manager (NTLM) Kerberos Passwords can be further secured by salting the hash. This is the process of adding random characters at the beginning or end of the password to generate a completely different hash. If a hacker intercepts the hash, they must also know which portion is the salt before beginning to crack the hash. Hash Collisions Hashing is a good file verification method, but it is not perfect. Depending on the algorithm used, there is a potential for hash collisions. A hash collision occurs when two completely different files generate the same hash. Rainbow table attacks take advantage of hash collisions. A rainbow table is a table of passwords and their generated hashes. A hacker can use this table to try to match hashes instead of the actual password. Hash collisions can be reduced using an algorithm that generates a longer hash and by salting the hash. Salt is random data used as an additional input to the function that hashes data. Hashing Algorithms The two most popular implementations of hash algorithms are the Secure Hash Algorithm (SHA) and Message-Digest Algorithm #5 (MD5). Depending on the use, there are different hashing algorithms which can be used. The following table covers some of the more common algorithms. Hashing Algorithm Description Secure Hash Algorithm (SHA) SHA is a family of hashes. SHA is a government standard and is considered the strongest algorithm. First published in 1991 by the National Institute of Standards and Technology (NIST). SHA-2 was published in 2001 and has become one of the standard hash functions used today. Used in many security protocols such as TLS, SSL, PGP, SSH, and IPSec. Generates message digests that are 224, 256, 384, or 512 bits in size. The longer digests are considered more secure, with the most popular variant being SHA256, which produces a 256-bit digest. SHA-3 was published in 2015 but is not meant to replace SHA-2. SHA-2 has yet to be cracked. NIST wanted an alternative available for people to use. Message digests generated by SHA-3 are fully compatible with SHA-2. Computing an SHA value from a file Screenshot used with permission from Microsoft Description Message-Digest Algorithm 5 (MD5) MD5 was developed by Ron Rivest in 1991. MD5 generates a 128-bit message digest. Many security vulnerabilities have been discovered with MD5. As such, it is no longer viable for security purposes. MD5 is extremely susceptible to hash collisions. MD5 is mainly used for file integrity. MD5 is not considered safe for use, but it might be required for compatibility between security products. Hash-Based Message Authentication Code (HMAC) HMAC is a type of message authentication code. Like a digital signature, HMAC allows a user to verify that a file or message is legitimate. The message sender provides a secret key that is used with a hash function, such as MD5 or SHA, to create a message authentication code. The recipient then uses the key to verify both the integrity and authenticity of the message. RACE Integrity Primitives Evaluation Message Digest (RIPEMD) RIPEMD (RACE Integrity Primitives Evaluation Message Digest, or RIPE Message Digest) is a family of cryptographic hash functions that was first developed in 1992 as part of the EU's RIPE project. The first version was based on the MD4 function. In 1996, in response to security issues discovered in the first version, Belgian researchers developed four updated algorithms.",
      "summary": "Hashing algorithms like SHA-256 and MD5 generate fixed-length digest values to verify file integrity, authenticate digital signatures through asymmetric encryption, and secure credential exchanges in protocols like CHAP and Kerberos. Hash collisions occur when different inputs produce identical hashes, making rainbow table attacks possible, which can be mitigated using longer hash algorithms and salt values. Popular implementations include SHA family (government standard with 224-512 bit digests), deprecated MD5 (128-bit, vulnerable to collisions), and HMAC for message authentication using secret keys.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.3",
        "title": "Hashing Facts",
        "content_type": "text",
        "filename": "3.3.3_Hashing_Facts_[text].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.3_Hashing_Facts_[text].txt",
        "word_count": 2064,
        "has_content": true
      },
      "section_header": "Hashing is often used for the following:",
      "timestamp_range": null
    },
    {
      "chunk_id": "3.3.3_chunk_4",
      "content": "RIPEMD-160",
      "summary": "RIPEMD-160 is a cryptographic hash function that produces a 160-bit hash digest, designed as a secure alternative to SHA-1 with similar output length but different internal structure. It processes input data through parallel computation paths using five rounds of operations, providing collision resistance and data integrity verification for digital signatures and authentication systems. RIPEMD-160 offers comparable security to SHA-1 while maintaining independence from NSA-designed algorithms, making it suitable for applications requiring cryptographic hash functions with proven resistance to known attack methods.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.3",
        "title": "Hashing Facts",
        "content_type": "text",
        "filename": "3.3.3_Hashing_Facts_[text].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.3_Hashing_Facts_[text].txt",
        "word_count": 2064,
        "has_content": true
      },
      "section_header": "RIPEMD-128",
      "timestamp_range": null
    },
    {
      "chunk_id": "3.3.3_chunk_5",
      "content": "RIPEMD-320 RIPEMD is not as popular as SHA-2 but is used frequently with Bitcoin and other cryptocurrencies. Comparing Hash Values Being able to compare the hash of a file after it has been downloaded to a known good hash helps verify that the file was not altered in transit. Get-FileHash Get-FileHash Download.zip -a md5 Sample output from Get-FileHash Description Get-Content Get-Content Download.txt -eq \"39C784349F4ZDB44A84C7958C246E394\" -eq \"4A84C7958C246E39439C784349F4ZDB4\" The output will be \"True\" if the hashes match or \"False\" if they do not match.",
      "summary": "RIPEMD-320 is a cryptographic hash algorithm commonly used in Bitcoin and cryptocurrency applications, though less popular than SHA-2. Hash comparison using tools like PowerShell's Get-FileHash command enables file integrity verification by comparing downloaded file hashes against known good values to detect unauthorized modifications during transit. The Get-Content command can automate hash comparison, returning \"True\" for matching hashes or \"False\" for mismatched values, providing essential file authentication capabilities.",
      "metadata": {
        "chapter_num": "3",
        "section_num": "3.3.3",
        "title": "Hashing Facts",
        "content_type": "text",
        "filename": "3.3.3_Hashing_Facts_[text].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/03_Cryptographic_Solutions/3.3.3_Hashing_Facts_[text].txt",
        "word_count": 2064,
        "has_content": true
      },
      "section_header": "RIPEMD-256",
      "timestamp_range": null
    }
  ],
  "num_chunks": 5,
  "document_summary": "Hashing Facts (text): A threat actor can generate hashes to find a match for a hash captured from network traffic or a password file. It simply means that an attacker cannot use precomputed tables of hashes. This is the process of adding random characters at the beginning or end of the password to generate a completely different hash."
}