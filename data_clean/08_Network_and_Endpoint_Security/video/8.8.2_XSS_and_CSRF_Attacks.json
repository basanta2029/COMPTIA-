{
  "metadata": {
    "chapter_num": "8",
    "section_num": "8.8.2",
    "title": "XSS and CSRF Attacks",
    "content_type": "video",
    "filename": "8.8.2_XSS_and_CSRF_Attacks_[video].txt",
    "file_path": "data_raw/08_Network_and_Endpoint_Security/8.8.2_XSS_and_CSRF_Attacks_[video].txt",
    "word_count": 1979,
    "has_content": true
  },
  "full_content": "Transcript close interactive script In this lesson we're going to talk about Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF). Both of these exploits are web application exploits and take advantage of a web browser's ability to execute code on the client. This allows an attacker to gain access to information on the user's computer or to trick the user into providing information that the attacker can get access to. Cross-site Scripting Attacks are a type of injection attack where malicious code is saved onto an otherwise benign site. For example, a site that allows a user to provide input and display that back to users, such as a forum, could be used by malicious individuals to save and execute a client-side script if the input isn't properly sanitized. These scripts can then be used to gather information from a user's computer. Sometimes, cross-site scripting attacks take advantage of how web developers store information on a user's computer using cookies. Cookies are commonly used to store information when a user is logged in. Typically, this is a unique session key that's temporarily stored and associated with a particular user. The browser sends this information to the server as part of the header for each request that it makes to the server, and the unique session key identifies that the user is currently logged in, thus avoiding the need to send user names and passwords for each request. This approach isn't necessarily bad. However, if other vulnerabilities exist, an attacker can covertly steal this information by executing a client-side script requesting cookies for that domain. It then displays those cookies as part of the HTML page that is returned. To identify a vulnerable website, attackers will see if they can pass small snippets of text through an input field. For example, many websites will have a form that takes some input. If the developer doesn't sanitize the inputs, these input fields can be used to execute code. Many attackers will use a simple JavaScript alert to see if vulnerabilities exist. If not properly sanitized, a script like this pops up an alert saying, —œvulnerable.— Once a site is found to be vulnerable, a more complicated script is run that has the browser send cookies for the current site. With this information, the attacker can then gain access to the system and get more sensitive and valuable information like credit cards or personal identifying information. Another attack to know is the Cross-Site Request Forgery Attack, which is usually abbreviated as CSRF [/see-SURF/]. A CSRF attack is a malicious exploit where unwanted commands are executed on a website where the user has already been authenticated. For instance, if a user has already logged onto a site, an attacker could update his or her password by simply sending the appropriate parameters to the password reset page. Cross-site request forgery is often called a One-Click Attack because all that a user needs to do is click a link on a webpage or in an email that contains the malicious code. If the website doesn't have anti-forgery protections, the code can automatically update information without further intervention. Now, unlike cross-site scripting, which exploits the trust the user has for a particular website, CSRF exploits trust in the other direction. It exploits the trust that the website has for the end-user's browser. Let's look at how it works. The CSRF attack works by including a link, or even a script, in either a web page, an email message, or an instant message that accesses a site to which the user has already been authenticated. This is why we say it exploits the website's trust in the end-user's browser. Now, several things must happen for this to work. First, the website must rely on a user's identity. A good example is your bank's website that you log into to manage your bank account. That website has to trust the end-user's identity via some mechanism in the web browser. A classic example is a cookie. After that, this attack uses this information to trick the web browser into sending an HTTP request to this targeted site without the end-user's knowledge. If the targeted website has developed their application correctly by requiring an authenticated end-user to confirm specific actions, then this type of attack won't work. However, many websites perform actions based on user input without requiring the end-user to confirm those actions. And this is where we get into trouble. For example, many websites have a Remember Me� checkbox that doesn't require users to re-enter their username and password on subsequent visits to that site you're automatically logged in. When you select that checkbox, you are essentially telling the website to create and save a session cookie on your computer. A CSRF attack could then leverage this cookie to send an HTTP request to the site to perform some type of unwanted action, such as changing the user's password. Let's walk through an example of a CSRF attack to help you better understand how it works. Suppose you get an email message with the subject line, Check out this funny picture You're in the mood for a laugh, so you open the email. When you do, you don't see any image the image link appears to be broken. A couple of days later, you realize that your bank account has been drained. You've been the victim of a CSRF attack. What happened is the \"funny picture\" email contained underlying HTML code that executed when you opened the email. Here's what a normal HTML image tag looks like. Notice the file extension at the end. However, here's what a CSRF exploit would look like. Notice the link here. Instead of downloading the image, this code automatically executes, which uses the saved cookie on your computer to authenticate to your bank's website allowing the attacker to transfer your money. You may have noticed that almost all email clients nowadays automatically disable images. You now must click an option to view images in these email message. The reason for this is to prevent CSRF attacks. CSRF attacks can be tricky to pull off. There are several factors that need to be in place for these attacks to work. First, the target website must not check the referring header of the HTTP request. And while this is more common than you would think, a properly secured website will check for this. Second, the attacker must understand the form submission syntax at the target site so they can construct the appropriate URL. This step is relatively easy. Third, the attacker must know some key pieces of personal information required by the form. In this example, they must know the account number of the victim and how to plug that into the URL. And finally, the user authentication to that website must meet two criteria: it needs to be possible, and it must be transparent to the user. In other words, the website can't ask the user to confirm that they want to authenticate to the site and that they want to complete the transaction. This can be accomplished in two ways. One way is by using a saved session cookie, such as in this example. The second way is simply hoping that the user is currently logged into that website. It's important to note that a CSRF attack is what we call a Blind Attack, meaning that the attacker can't see what happens; they can't see the response that the target website sends back to the victim's web browser after the forged request is sent. Also, attackers will have a difficult time if the website responds with some type of confirmation, a second form, or other information that must be submitted after the initial URL is executed. There are ways around this, however. For example, the attacker could include multiple images in the email message which will complete each subsequent step in the transfer process: the first image would initiate the transfer from one account to another, the second image might specify when to execute the transfer, and the third image might confirm the transfer. Now as you can see this is a fairly complex attack, but it's not impossible. It's essential to follow these two steps to protect organizations and end users from CSRF attacks. The first step is to implement secure web development and authentication practices. For example, a lot of web application frameworks support anti-forgery mechanisms, such as the ability to create paired tokens that are mathematically related. One token is saved in a cookie on the client. A second token is saved in the form that is used to submit information. In order for the form to be submitted, these two tokens must match, or an error will occur. Another mechanism to implement is an idle timeout that automatically ends a user's session if they have been idle for too long. A lot of banking websites actually have this functionality. The second step is to train end users to protect themselves from CSRF attacks. Teach them that if they log into a website that requires authentication of some sort a banking site or eCommerce site they should immediately log out when they are done using that site. They should also close the browser tab or browser window. It's problematic when users stay logged into services after they are done using them. This opens them up to CSRF attacks because they are authenticated to that service. Another concern is Remember Me check boxes. While this feature is often convenient, it does increase the likelihood that a CSRF attack will succeed. As such, train users never to use this feature. And finally, train users to never load images or accept instant messages from unknown sources. Even though many email clients and IM applications will automatically hide or block images from unknown sources, it's still possible for the end user to choose to download those images. Therefore, make sure to train users never to download or load images from unknown or suspicious sources. That's it for this demonstration. In this lesson, we talked about cross-site scripting (XSS) and cross-site request forgery (CSRF). We looked at how they work, some example attacks, and what you can do to protect your organization from these threats.",
  "chunks": [
    {
      "chunk_id": "8.8.2_chunk_1",
      "content": "In this lesson we're going to talk about Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF). Both of these exploits are web application exploits and take advantage of a web browser's ability to execute code on the client. This allows an attacker to gain access to information on the user's computer or to trick the user into providing information that the attacker can get access to.",
      "summary": "This lesson covers Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF), two common web application vulnerabilities that exploit a browser's capability to execute client-side code. XSS allows attackers to access sensitive information on a user's device, while CSRF tricks users into performing actions without their consent, potentially compromising their data. Understanding these attacks is crucial for implementing effective security measures in web applications.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.8.2",
        "title": "XSS and CSRF Attacks",
        "content_type": "video",
        "filename": "8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "word_count": 1979,
        "has_content": true
      },
      "section_header": "XSS and CSRF Attacks",
      "timestamp_range": ""
    },
    {
      "chunk_id": "8.8.2_chunk_2",
      "content": "Cross-site Scripting Attacks are a type of injection attack where malicious code is saved onto an otherwise benign site. For example, a site that allows a user to provide input and display that back to users, such as a forum, could be used by malicious individuals to save and execute a client-side script if the input isn't properly sanitized. These scripts can then be used to gather information from a user's computer. Sometimes, cross-site scripting attacks take advantage of how web developers store information on a user's computer using cookies. Cookies are commonly used to store information when a user is logged in. Typically, this is a unique session key that's temporarily stored and associated with a particular user. The browser sends this information to the server as part of the header for each request that it makes to the server, and the unique session key identifies that the user is currently logged in, thus avoiding the need to send user names and passwords for each request. This approach isn't necessarily bad. However, if other vulnerabilities exist, an attacker can covertly steal this information by executing a client-side script requesting cookies for that domain. It then displays those cookies as part of the HTML page that is returned. To identify a vulnerable website, attackers will see if they can pass small snippets of text through an input field. For example, many websites will have a form that takes some input. If the developer doesn't sanitize the inputs, these input fields can be used to execute code. Many attackers will use a simple JavaScript alert to see if vulnerabilities exist. If not properly sanitized, a script like this pops up an alert saying, —œvulnerable.— Once a site is found to be vulnerable, a more complicated script is run that has the browser send cookies for the current site. With this information, the attacker can then gain access to the system and get more sensitive and valuable information like credit cards or personal identifying information.",
      "summary": "Cross-Site Scripting (XSS) attacks involve injecting malicious scripts into benign websites, often through unsanitized user input fields, allowing attackers to execute client-side scripts that can steal sensitive information, such as cookies containing session keys. These attacks exploit vulnerabilities in web applications, enabling attackers to gather data from users' computers and potentially access more sensitive information like credit card details or personal identifiers. Understanding and mitigating XSS risks is crucial for web developers to protect user data and maintain application security.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.8.2",
        "title": "XSS and CSRF Attacks",
        "content_type": "video",
        "filename": "8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "word_count": 1979,
        "has_content": true
      },
      "section_header": "Cross-Site Scripting (XSS) Attacks",
      "timestamp_range": ""
    },
    {
      "chunk_id": "8.8.2_chunk_3",
      "content": "Another attack to know is the Cross-Site Request Forgery Attack, which is usually abbreviated as CSRF [/see-SURF/]. A CSRF attack is a malicious exploit where unwanted commands are executed on a website where the user has already been authenticated. For instance, if a user has already logged onto a site, an attacker could update his or her password by simply sending the appropriate parameters to the password reset page. Cross-site request forgery is often called a One-Click Attack because all that a user needs to do is click a link on a webpage or in an email that contains the malicious code. If the website doesn't have anti-forgery protections, the code can automatically update information without further intervention. Now, unlike cross-site scripting, which exploits the trust the user has for a particular website, CSRF exploits trust in the other direction. It exploits the trust that the website has for the end-user's browser. Let's look at how it works.",
      "summary": "Cross-Site Request Forgery (CSRF) attacks exploit the trust a website has in an authenticated user's browser, allowing attackers to execute unwanted commands without the user's consent. Often referred to as One-Click Attacks, these exploits can change user information, such as passwords, by simply tricking the user into clicking a malicious link. To mitigate CSRF risks, websites should implement anti-forgery protections to validate requests and ensure they originate from legitimate users.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.8.2",
        "title": "XSS and CSRF Attacks",
        "content_type": "video",
        "filename": "8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "word_count": 1979,
        "has_content": true
      },
      "section_header": "Cross-Site Request Forgery (CSRF) Attacks",
      "timestamp_range": ""
    },
    {
      "chunk_id": "8.8.2_chunk_4",
      "content": "The CSRF attack works by including a link, or even a script, in either a web page, an email message, or an instant message that accesses a site to which the user has already been authenticated. This is why we say it exploits the website's trust in the end-user's browser. Now, several things must happen for this to work. First, the website must rely on a user's identity. A good example is your bank's website that you log into to manage your bank account. That website has to trust the end-user's identity via some mechanism in the web browser. A classic example is a cookie. After that, this attack uses this information to trick the web browser into sending an HTTP request to this targeted site without the end-user's knowledge. If the targeted website has developed their application correctly by requiring an authenticated end-user to confirm specific actions, then this type of attack won't work. However, many websites perform actions based on user input without requiring the end-user to confirm those actions. And this is where we get into trouble. For example, many websites have a Remember Me� checkbox that doesn't require users to re-enter their username and password on subsequent visits to that site you're automatically logged in. When you select that checkbox, you are essentially telling the website to create and save a session cookie on your computer. A CSRF attack could then leverage this cookie to send an HTTP request to the site to perform some type of unwanted action, such as changing the user's password.",
      "summary": "A Cross-Site Request Forgery (CSRF) attack exploits the trust a website has in a user's browser by tricking it into sending unauthorized HTTP requests to a site where the user is already authenticated, often using session cookies. This type of attack can succeed if the website does not require user confirmation for sensitive actions, allowing attackers to perform unwanted operations, such as changing passwords. To mitigate CSRF risks, developers should implement measures that require user validation for critical actions.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.8.2",
        "title": "XSS and CSRF Attacks",
        "content_type": "video",
        "filename": "8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "word_count": 1979,
        "has_content": true
      },
      "section_header": "How a CSRF Attack Works",
      "timestamp_range": ""
    },
    {
      "chunk_id": "8.8.2_chunk_5",
      "content": "Let's walk through an example of a CSRF attack to help you better understand how it works. Suppose you get an email message with the subject line, Check out this funny picture You're in the mood for a laugh, so you open the email. When you do, you don't see any image the image link appears to be broken. A couple of days later, you realize that your bank account has been drained. You've been the victim of a CSRF attack. What happened is the \"funny picture\" email contained underlying HTML code that executed when you opened the email. Here's what a normal HTML image tag looks like. Notice the file extension at the end. However, here's what a CSRF exploit would look like. Notice the link here. Instead of downloading the image, this code automatically executes, which uses the saved cookie on your computer to authenticate to your bank's website allowing the attacker to transfer your money. You may have noticed that almost all email clients nowadays automatically disable images. You now must click an option to view images in these email message. The reason for this is to prevent CSRF attacks.",
      "summary": "The CSRF (Cross-Site Request Forgery) attack example illustrates how an attacker can exploit a user's session by embedding malicious HTML code in an email, leading to unauthorized actions on a legitimate website, such as draining a bank account. This attack leverages the user's saved authentication cookies, allowing the attacker to execute transactions without the user's consent. To mitigate such risks, modern email clients disable automatic image loading, requiring users to manually enable images, thereby reducing the likelihood of CSRF attacks.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.8.2",
        "title": "XSS and CSRF Attacks",
        "content_type": "video",
        "filename": "8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "word_count": 1979,
        "has_content": true
      },
      "section_header": "CSRF in Action",
      "timestamp_range": ""
    },
    {
      "chunk_id": "8.8.2_chunk_6",
      "content": "CSRF attacks can be tricky to pull off. There are several factors that need to be in place for these attacks to work. First, the target website must not check the referring header of the HTTP request. And while this is more common than you would think, a properly secured website will check for this. Second, the attacker must understand the form submission syntax at the target site so they can construct the appropriate URL. This step is relatively easy. Third, the attacker must know some key pieces of personal information required by the form. In this example, they must know the account number of the victim and how to plug that into the URL. And finally, the user authentication to that website must meet two criteria: it needs to be possible, and it must be transparent to the user. In other words, the website can't ask the user to confirm that they want to authenticate to the site and that they want to complete the transaction. This can be accomplished in two ways. One way is by using a saved session cookie, such as in this example. The second way is simply hoping that the user is currently logged into that website.",
      "summary": "Cross-Site Request Forgery (CSRF) attacks require specific conditions to succeed, including a target website that does not verify the HTTP referrer header and an attacker who understands the site's form submission syntax. Additionally, the attacker must possess key personal information, like the victim's account number, and exploit user authentication that is seamless, often relying on saved session cookies or the victim being logged in. Understanding these elements is crucial for implementing effective defenses against CSRF vulnerabilities.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.8.2",
        "title": "XSS and CSRF Attacks",
        "content_type": "video",
        "filename": "8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "word_count": 1979,
        "has_content": true
      },
      "section_header": "CSRF Win Conditions",
      "timestamp_range": ""
    },
    {
      "chunk_id": "8.8.2_chunk_7",
      "content": "It's important to note that a CSRF attack is what we call a Blind Attack, meaning that the attacker can't see what happens; they can't see the response that the target website sends back to the victim's web browser after the forged request is sent. Also, attackers will have a difficult time if the website responds with some type of confirmation, a second form, or other information that must be submitted after the initial URL is executed. There are ways around this, however. For example, the attacker could include multiple images in the email message which will complete each subsequent step in the transfer process: the first image would initiate the transfer from one account to another, the second image might specify when to execute the transfer, and the third image might confirm the transfer. Now as you can see this is a fairly complex attack, but it's not impossible.",
      "summary": "A Cross-Site Request Forgery (CSRF) attack is classified as a Blind Attack, where the attacker cannot observe the response from the target website after sending a forged request. While challenges arise if the website requires additional confirmation or information, attackers can design complex strategies, such as using multiple images in an email to automate the steps of the transfer process. Understanding these tactics is crucial for implementing effective security measures against such vulnerabilities.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.8.2",
        "title": "XSS and CSRF Attacks",
        "content_type": "video",
        "filename": "8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "word_count": 1979,
        "has_content": true
      },
      "section_header": "A Blind Attack",
      "timestamp_range": ""
    },
    {
      "chunk_id": "8.8.2_chunk_8",
      "content": "It's essential to follow these two steps to protect organizations and end users from CSRF attacks. The first step is to implement secure web development and authentication practices. For example, a lot of web application frameworks support anti-forgery mechanisms, such as the ability to create paired tokens that are mathematically related. One token is saved in a cookie on the client. A second token is saved in the form that is used to submit information. In order for the form to be submitted, these two tokens must match, or an error will occur. Another mechanism to implement is an idle timeout that automatically ends a user's session if they have been idle for too long. A lot of banking websites actually have this functionality. The second step is to train end users to protect themselves from CSRF attacks. Teach them that if they log into a website that requires authentication of some sort a banking site or eCommerce site they should immediately log out when they are done using that site. They should also close the browser tab or browser window. It's problematic when users stay logged into services after they are done using them. This opens them up to CSRF attacks because they are authenticated to that service. Another concern is Remember Me check boxes. While this feature is often convenient, it does increase the likelihood that a CSRF attack will succeed. As such, train users never to use this feature. And finally, train users to never load images or accept instant messages from unknown sources. Even though many email clients and IM applications will automatically hide or block images from unknown sources, it's still possible for the end user to choose to download those images. Therefore, make sure to train users never to download or load images from unknown or suspicious sources.",
      "summary": "To prevent CSRF attacks, organizations should implement secure web development practices, such as using paired anti-forgery tokens and setting idle timeouts for user sessions. Additionally, user education is crucial; individuals should be trained to log out of authenticated sessions, avoid using \"Remember Me\" features, and refrain from loading images or messages from unknown sources to enhance their security posture. These combined measures help mitigate the risk of CSRF vulnerabilities effectively.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.8.2",
        "title": "XSS and CSRF Attacks",
        "content_type": "video",
        "filename": "8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "word_count": 1979,
        "has_content": true
      },
      "section_header": "Preventing a CSRF Attack",
      "timestamp_range": ""
    },
    {
      "chunk_id": "8.8.2_chunk_9",
      "content": "That's it for this demonstration. In this lesson, we talked about cross-site scripting (XSS) and cross-site request forgery (CSRF). We looked at how they work, some example attacks, and what you can do to protect your organization from these threats.",
      "summary": "This lesson covers cross-site scripting (XSS) and cross-site request forgery (CSRF), two prevalent web security vulnerabilities. It explains their mechanisms, provides examples of attacks, and outlines protective measures organizations can implement to mitigate these risks. Understanding these concepts is crucial for enhancing web application security and safeguarding user data.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.8.2",
        "title": "XSS and CSRF Attacks",
        "content_type": "video",
        "filename": "8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.8.2_XSS_and_CSRF_Attacks_[video].txt",
        "word_count": 1979,
        "has_content": true
      },
      "section_header": "Summary",
      "timestamp_range": ""
    }
  ],
  "num_chunks": 9
}