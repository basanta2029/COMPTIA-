{
  "metadata": {
    "chapter_num": "8",
    "section_num": "8.9.3",
    "title": "SDLC and Development Facts",
    "content_type": "text",
    "filename": "8.9.3_SDLC_and_Development_Facts_[text].txt",
    "file_path": "data_raw/08_Network_and_Endpoint_Security/8.9.3_SDLC_and_Development_Facts_[text].txt",
    "word_count": 1452,
    "has_content": true
  },
  "full_content": "Security Pro 8.0 Even though you may not be a software developer, most security professionals at some point work with software engineers who develop applications. And just like any other enterprise component, these applications need to be properly secured. Waterfall development life cycle model Agile development life cycle model Coding errors Error handling Static code analysis Software sandboxing Waterfall Development Life Cycle Model The most widely used development model is the Waterfall model. It is called this because each step is completed before the next step is begun so that each step flows to the next. Step Description Requirements\tAll requirements for the application being developed are gathered from the client, user, or stakeholder. Design\tThe software is documented, diagramed, and designed. Implementation\tThe code is written. Testing\tA quality assurance team makes sure requirements are met, the code works properly across devices, and security issues are noted. Deployment\tThe application is released to a client or the public. Maintenance\tThe application is monitored for bugs or problems that are patched or fixed while in use. This is an ongoing stage that continues throughout the life of the app. Understand that an application will likely go through some of these steps multiple times before moving to the next step. For example, the application might go through the Design step five times before it’s ready to move to the Implementation step. Or the application may move back from the Implementation stage to the Design stage if a new feature needs to be added. This entire development life cycle is a slow process and may take months or years to complete. The Waterfall method also lacks flexibility since the requirements determined in the beginning are carried through to the end product. Description Agile Development Life Cycle Model A more agile approach was introduced in 2001 that approaches software development as a continuous, changing process with never-ending versions, bug fixes, and enhancements. This approach is aptly named Agile. It breaks development into smaller time frames called Sprints. Each Sprint has a specific duration(usually two to three weeks). Developers work on one feature during a Sprint. At the end of each Sprint, developers move on to the next feature. Testing is performed throughout the development cycle. Description Coding Errors Coding errors and design flaws are the main causes of software vulnerabilities. We can categorize these errors into two types: Coding Error Type Description Compile An error that occurs during the building or compilation stage Error compromises the software implementation Prevents the app from running Runtime An error that occurs while software is running Sometimes called bugs Error Handling A well-written application must be able to handle errors and  exceptions gracefully. This means that the application performs in a controlled way when something unpredictable happens. An error or exception could be caused by invalid user input, a loss of network connectivity, another server or process failing, etc. Ideally, the programmer will have written a  structured exception handler (SEH) to dictate what the application should do. Each procedure can have multiple exception handlers. Some handlers will deal with anticipated errors and exceptions; there should also be a catchall handler that will deal with the unexpected. The main goal must be for the application not to fail in a way that allows the attacker to execute code or perform some sort of injection attack. One infamous example of a poorly written exception handler is the Apple GoTo bug( nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch ). Another issue is that an application's interpreter may default to a standard handler and display default error messages when something goes wrong. These may reveal platform information and the inner workings of code to an attacker. It is better for an application to use custom error handlers so that the developer can choose the amount of information shown when an error is caused. Technically, an error is a condition that the process cannot recover from, such as the system running out of memory. An exception is a type of error that can be handled by a block of code without the process crashing. Note that exceptions are still described as generating error codes/messages, however. Static Code Analysis Static code analysis is a crucial software development practice. It involves scrutinizing source code to identify potential vulnerabilities, errors, and non-compliant coding practices before the program is finalized. By examining code in a 'static' state, developers can catch and rectify issues early in the development lifecycle. This makes it a proactive approach to building secure, reliable, high-quality software. Application security approaches focus on software development and deployment lifecycles, with a heavy emphasis on secure coding practices that encourage developers to write code that prevents common vulnerabilities like SQL injection and cross-site scripting. Application security practices also mandate static and dynamic application security testing(SAST). Coding practices designed to support regular patching and updates are crucial to support the prompt resolution of newly discovered vulnerabilities. Static code analysis supports secure coding and is performed using specialized tools, often integrated into software development suites. These tools automate code checks against pre-determined rules and flag potential issues so developers can review and address them. Some commonly used static analysis tools include SonarQube, Coverity, and Fortify, but there are many others. Static code analysis in software development is critical because it enables early detection of bugs and security vulnerabilities and helps prevent potentially catastrophic failures in the final product. It also improves code quality and maintainability by enforcing coding standards and best practices. Additionally, static code analysis helps educate developers about common coding errors and security risks, which helps promote security-conscious development practices. During the coding and design phases of development, you can increase development and application security by implementing a few key practices. Integrate security testing into each step in the development process. Secure Testing Method Description Static application security testing Known as white box testing Focuses on analyzing source code, binaries, and byte code early in the development process Good at identifying things like SQL injections and buffer overflows Only in code that's written but not deployed Is language specific Can run continually and be widely applied Has a high percentage of false positives Limited in the types of vulnerabilities it can detect Dynamic application security testing Known as black box testing Scans applications after deployment Tests from the outside Uses a series of tests to determine vulnerabilities and flaws Not language specific Has fewer false positives Hard to automate Cannot pinpoint the cause of a flaw Can take up to a week to complete the testing process Interactive application security testing Passive: Interactive functionality is built into static application security testing. Uses source code scanners during runtime. Testing tools can access interpreters and compilers, allowing precise identification of a problematic line of code in runtime. Speeds up testing and remediation. Can help in the Development stage by catching vulnerabilities early. Can help in the QA stage by adding automated security checkpoints. Can help in the Production stage through continuous monitoring. Software Sandboxing Sandboxing is a security mechanism used in software development and operation to isolate running processes from each other or prevent them from accessing the system they are running on. A sandbox is a protection feature designed to control a program so it runs with highly restrictive access. This containment strategy reduces the potential impact of malicious or malfunctioning software, making it effective for improving system security and stability and mitigating risks associated with software. A practical example of sandboxing is implemented in modern web browsers, like Google Chrome, which separates each tab and extension into distinct processes. If a website or browser extension in one browser tab attempts to run malicious code, it is confined within that tab's sandbox. This action prevents malicious code from impacting the entire browser or underlying operating system. Similarly, if a tab crashes, it doesn't cause the whole browser to fail, improving reliability. Operating systems also utilize sandboxing to isolate applications. For example, iOS and Android use sandboxing to limit each application's actions. An app in a sandbox can access its own data and resources but cannot access other app data or any nonessential system resources without explicit permission. This approach limits the damage caused by poorly written or malicious apps. Virtual machines(VMs) and containers like Docker offer another example of sandboxing at a larger scale. Each VM or container can run in isolation, separated from the host and each other. The others remain unaffected if one VM or container experiences a security breach or system failure.",
  "chunks": [
    {
      "chunk_id": "8.9.3_chunk_1",
      "content": "Security Pro 8.0",
      "summary": "The CompTIA Security+ course, Security Pro 8.0, introduces essential cybersecurity concepts, including risk management, threat identification, and incident response. Key topics cover network security, compliance, and operational security, emphasizing the importance of protecting information systems. Practical applications involve hands-on exercises and real-world scenarios to equip learners with the skills needed to secure networks and data effectively.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.9.3",
        "title": "SDLC and Development Facts",
        "content_type": "text",
        "filename": "8.9.3_SDLC_and_Development_Facts_[text].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.9.3_SDLC_and_Development_Facts_[text].txt",
        "word_count": 1452,
        "has_content": true
      },
      "section_header": "Introduction",
      "timestamp_range": null
    },
    {
      "chunk_id": "8.9.3_chunk_2",
      "content": "Even though you may not be a software developer, most security professionals at some point work with software engineers who develop applications. And just like any other enterprise component, these applications need to be properly secured.",
      "summary": "The Software Development Life Cycle (SDLC) is crucial for integrating security into application development, emphasizing the need for security professionals to collaborate with software engineers. Key concepts include identifying security requirements, implementing secure coding practices, and conducting thorough testing to mitigate vulnerabilities. Understanding the SDLC enables security professionals to ensure that applications are developed with security considerations from the outset, enhancing overall enterprise security.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.9.3",
        "title": "SDLC and Development Facts",
        "content_type": "text",
        "filename": "8.9.3_SDLC_and_Development_Facts_[text].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.9.3_SDLC_and_Development_Facts_[text].txt",
        "word_count": 1452,
        "has_content": true
      },
      "section_header": "8.9.3 SDLC and Development Facts",
      "timestamp_range": null
    },
    {
      "chunk_id": "8.9.3_chunk_3",
      "content": "Waterfall development life cycle model Agile development life cycle model Coding errors Error handling Static code analysis Software sandboxing Waterfall Development Life Cycle Model The most widely used development model is the Waterfall model. It is called this because each step is completed before the next step is begun so that each step flows to the next.",
      "summary": "This lesson explores key software development life cycle models, focusing on the Waterfall and Agile methodologies. It emphasizes the importance of identifying and managing coding errors through techniques such as error handling, static code analysis, and software sandboxing. Understanding these concepts is crucial for implementing secure coding practices and enhancing overall software security.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.9.3",
        "title": "SDLC and Development Facts",
        "content_type": "text",
        "filename": "8.9.3_SDLC_and_Development_Facts_[text].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.9.3_SDLC_and_Development_Facts_[text].txt",
        "word_count": 1452,
        "has_content": true
      },
      "section_header": "This lesson covers the following topics:",
      "timestamp_range": null
    },
    {
      "chunk_id": "8.9.3_chunk_4",
      "content": "Step Description Requirements\tAll requirements for the application being developed are gathered from the client, user, or stakeholder. Design\tThe software is documented, diagramed, and designed. Implementation\tThe code is written. Testing\tA quality assurance team makes sure requirements are met, the code works properly across devices, and security issues are noted. Deployment\tThe application is released to a client or the public. Maintenance\tThe application is monitored for bugs or problems that are patched or fixed while in use. This is an ongoing stage that continues throughout the life of the app. Understand that an application will likely go through some of these steps multiple times before moving to the next step. For example, the application might go through the Design step five times before it’s ready to move to the Implementation step. Or the application may move back from the Implementation stage to the Design stage if a new feature needs to be added.",
      "summary": "The Waterfall development life cycle model consists of sequential steps: Requirements gathering, Design, Implementation, Testing, Deployment, and Maintenance. Each stage is crucial for ensuring that the application meets client needs and security standards, with the possibility of revisiting earlier steps as necessary to refine features or address issues. This structured approach emphasizes thorough documentation and quality assurance throughout the software development process.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.9.3",
        "title": "SDLC and Development Facts",
        "content_type": "text",
        "filename": "8.9.3_SDLC_and_Development_Facts_[text].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.9.3_SDLC_and_Development_Facts_[text].txt",
        "word_count": 1452,
        "has_content": true
      },
      "section_header": "The Waterfall development life cycle model steps are:",
      "timestamp_range": null
    },
    {
      "chunk_id": "8.9.3_chunk_5",
      "content": "This entire development life cycle is a slow process and may take months or years to complete. The Waterfall method also lacks flexibility since the requirements determined in the beginning are carried through to the end product. Description Agile Development Life Cycle Model A more agile approach was introduced in 2001 that approaches software development as a continuous, changing process with never-ending versions, bug fixes, and enhancements. This approach is aptly named Agile.",
      "summary": "The CompTIA Security+ course highlights the differences between traditional Waterfall and Agile development life cycles in software security. The Waterfall model is a linear, inflexible approach that can take months or years to complete, while the Agile model promotes continuous development, allowing for ongoing updates, bug fixes, and enhancements. Understanding these methodologies is crucial for implementing effective security measures throughout the software development process.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.9.3",
        "title": "SDLC and Development Facts",
        "content_type": "text",
        "filename": "8.9.3_SDLC_and_Development_Facts_[text].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.9.3_SDLC_and_Development_Facts_[text].txt",
        "word_count": 1452,
        "has_content": true
      },
      "section_header": "Note:",
      "timestamp_range": null
    },
    {
      "chunk_id": "8.9.3_chunk_6",
      "content": "It breaks development into smaller time frames called Sprints. Each Sprint has a specific duration(usually two to three weeks). Developers work on one feature during a Sprint. At the end of each Sprint, developers move on to the next feature. Testing is performed throughout the development cycle. Description Coding Errors Coding errors and design flaws are the main causes of software vulnerabilities. We can categorize these errors into two types: Coding Error Type Description Compile An error that occurs during the building or compilation stage Error compromises the software implementation Prevents the app from running Runtime An error that occurs while software is running Sometimes called bugs Error Handling A well-written application must be able to handle errors and  exceptions gracefully. This means that the application performs in a controlled way when something unpredictable happens. An error or exception could be caused by invalid user input, a loss of network connectivity, another server or process failing, etc. Ideally, the programmer will have written a  structured exception handler (SEH) to dictate what the application should do. Each procedure can have multiple exception handlers. Some handlers will deal with anticipated errors and exceptions; there should also be a catchall handler that will deal with the unexpected. The main goal must be for the application not to fail in a way that allows the attacker to execute code or perform some sort of injection attack. One infamous example of a poorly written exception handler is the Apple GoTo bug( nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch ). Another issue is that an application's interpreter may default to a standard handler and display default error messages when something goes wrong. These may reveal platform information and the inner workings of code to an attacker. It is better for an application to use custom error handlers so that the developer can choose the amount of information shown when an error is caused. Technically, an error is a condition that the process cannot recover from, such as the system running out of memory. An exception is a type of error that can be handled by a block of code without the process crashing. Note that exceptions are still described as generating error codes/messages, however. Static Code Analysis Static code analysis is a crucial software development practice. It involves scrutinizing source code to identify potential vulnerabilities, errors, and non-compliant coding practices before the program is finalized. By examining code in a 'static' state, developers can catch and rectify issues early in the development lifecycle. This makes it a proactive approach to building secure, reliable, high-quality software. Application security approaches focus on software development and deployment lifecycles, with a heavy emphasis on secure coding practices that encourage developers to write code that prevents common vulnerabilities like SQL injection and cross-site scripting. Application security practices also mandate static and dynamic application security testing(SAST). Coding practices designed to support regular patching and updates are crucial to support the prompt resolution of newly discovered vulnerabilities. Static code analysis supports secure coding and is performed using specialized tools, often integrated into software development suites. These tools automate code checks against pre-determined rules and flag potential issues so developers can review and address them. Some commonly used static analysis tools include SonarQube, Coverity, and Fortify, but there are many others. Static code analysis in software development is critical because it enables early detection of bugs and security vulnerabilities and helps prevent potentially catastrophic failures in the final product. It also improves code quality and maintainability by enforcing coding standards and best practices. Additionally, static code analysis helps educate developers about common coding errors and security risks, which helps promote security-conscious development practices. During the coding and design phases of development, you can increase development and application security by implementing a few key practices. Integrate security testing into each step in the development process. Secure Testing Method Description Static application security testing Known as white box testing Focuses on analyzing source code, binaries, and byte code early in the development process Good at identifying things like SQL injections and buffer overflows",
      "summary": "The Agile model enhances software development by breaking it into short, iterative cycles called Sprints, allowing for continuous testing and feature implementation. Key security concepts include the identification and management of coding errors, the importance of structured exception handling to prevent vulnerabilities, and the use of static code analysis to detect potential issues early in the development lifecycle. By integrating security practices throughout the development process, such as static application security testing, developers can create more secure and reliable applications while promoting awareness of common coding vulnerabilities.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.9.3",
        "title": "SDLC and Development Facts",
        "content_type": "text",
        "filename": "8.9.3_SDLC_and_Development_Facts_[text].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.9.3_SDLC_and_Development_Facts_[text].txt",
        "word_count": 1452,
        "has_content": true
      },
      "section_header": "The Agile model works in this manner:",
      "timestamp_range": null
    },
    {
      "chunk_id": "8.9.3_chunk_7",
      "content": "Only in code that's written but not deployed Is language specific Can run continually and be widely applied Has a high percentage of false positives Limited in the types of vulnerabilities it can detect Dynamic application security testing Known as black box testing Scans applications after deployment Tests from the outside Uses a series of tests to determine vulnerabilities and flaws Not language specific Has fewer false positives Hard to automate Cannot pinpoint the cause of a flaw Can take up to a week to complete the testing process Interactive application security testing",
      "summary": "This section covers various application security testing methodologies, highlighting the differences between static and dynamic testing. Static application security testing (SAST) is language-specific, can identify coding problems in undeployed code, but often yields false positives and is limited in vulnerability detection. In contrast, dynamic application security testing (DAST) operates post-deployment, is not language-specific, has fewer false positives, but is harder to automate and may take longer to identify specific flaws.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.9.3",
        "title": "SDLC and Development Facts",
        "content_type": "text",
        "filename": "8.9.3_SDLC_and_Development_Facts_[text].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.9.3_SDLC_and_Development_Facts_[text].txt",
        "word_count": 1452,
        "has_content": true
      },
      "section_header": "Can identify the exact cause of a coding problem:",
      "timestamp_range": null
    },
    {
      "chunk_id": "8.9.3_chunk_8",
      "content": "Passive: Interactive functionality is built into static application security testing. Uses source code scanners during runtime.",
      "summary": "The CompTIA Security+ course covers two types of application security testing: passive and active. Passive testing utilizes interactive functionality through static application security testing, employing source code scanners to analyze code during runtime without executing it. This approach helps identify vulnerabilities early in the development process, enhancing overall application security.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.9.3",
        "title": "SDLC and Development Facts",
        "content_type": "text",
        "filename": "8.9.3_SDLC_and_Development_Facts_[text].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.9.3_SDLC_and_Development_Facts_[text].txt",
        "word_count": 1452,
        "has_content": true
      },
      "section_header": "Has two types:",
      "timestamp_range": null
    },
    {
      "chunk_id": "8.9.3_chunk_9",
      "content": "Testing tools can access interpreters and compilers, allowing precise identification of a problematic line of code in runtime. Speeds up testing and remediation. Can help in the Development stage by catching vulnerabilities early. Can help in the QA stage by adding automated security checkpoints. Can help in the Production stage through continuous monitoring. Software Sandboxing Sandboxing is a security mechanism used in software development and operation to isolate running processes from each other or prevent them from accessing the system they are running on. A sandbox is a protection feature designed to control a program so it runs with highly restrictive access. This containment strategy reduces the potential impact of malicious or malfunctioning software, making it effective for improving system security and stability and mitigating risks associated with software. A practical example of sandboxing is implemented in modern web browsers, like Google Chrome, which separates each tab and extension into distinct processes. If a website or browser extension in one browser tab attempts to run malicious code, it is confined within that tab's sandbox. This action prevents malicious code from impacting the entire browser or underlying operating system. Similarly, if a tab crashes, it doesn't cause the whole browser to fail, improving reliability. Operating systems also utilize sandboxing to isolate applications. For example, iOS and Android use sandboxing to limit each application's actions. An app in a sandbox can access its own data and resources but cannot access other app data or any nonessential system resources without explicit permission. This approach limits the damage caused by poorly written or malicious apps. Virtual machines(VMs) and containers like Docker offer another example of sandboxing at a larger scale. Each VM or container can run in isolation, separated from the host and each other. The others remain unaffected if one VM or container experiences a security breach or system failure.",
      "summary": "The CompTIA Security+ course emphasizes the importance of testing tools that utilize interpreters and compilers to identify vulnerabilities early in the software development lifecycle, enhancing security during Development, QA, and Production stages. It highlights the concept of software sandboxing, a security mechanism that isolates processes to prevent malicious code from affecting the entire system, as seen in modern web browsers and mobile operating systems. Additionally, sandboxing is applied in virtual machines and containers, ensuring that breaches in one environment do not compromise others, thereby improving overall system security and stability.",
      "metadata": {
        "chapter_num": "8",
        "section_num": "8.9.3",
        "title": "SDLC and Development Facts",
        "content_type": "text",
        "filename": "8.9.3_SDLC_and_Development_Facts_[text].txt",
        "file_path": "data_raw/08_Network_and_Endpoint_Security/8.9.3_SDLC_and_Development_Facts_[text].txt",
        "word_count": 1452,
        "has_content": true
      },
      "section_header": "Active:",
      "timestamp_range": null
    }
  ],
  "num_chunks": 9
}