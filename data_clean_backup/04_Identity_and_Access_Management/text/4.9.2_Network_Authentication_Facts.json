{
  "metadata": {
    "chapter_num": "4",
    "section_num": "4.9.2",
    "title": "Network Authentication Facts",
    "content_type": "text",
    "filename": "4.9.2_Network_Authentication_Facts_[text].txt",
    "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.9.2_Network_Authentication_Facts_[text].txt",
    "word_count": 1724,
    "has_content": true
  },
  "full_content": "Security Pro 8.0 This lesson covers the following topics: Network authentication overview Single sign-on authentication Single sign-on authorization Federation Open authorization Network Authentication Overview Authentication is the process of validating user credentials that prove user identity. Authentication is typically the first step in connecting to a network. Following successful authentication, access controls can be implemented to allow or deny access to network resources. A simple form of authentication sends a username and password to an authentication server. If the password is sent in cleartext, the authentication credentials can be intercepted and used to impersonate an authorized user. One method of protecting login credentials is using a challenge/response mechanism (also called a three-way handshake). By doing so, both the authentication server and the authenticator are configured with a common shared secret. This shared secret is usually a password associated with a user account. The process is: The authentication server sends a challenge string to the authenticator. The authenticator uses the shared secret to hash the challenge string and returns the user account name and the hashed value to the authentication server. The authentication server also uses its shared secret value to hash the challenge string. If the two hashed values match, the authentication server assumes the authenticator knows the shared secret. Single Sign-on Authentication A single sign-on (SSO) system allows users to authenticate once and then receive authorizations on compatible application servers without entering credentials again. Kerberos is a single sign-on network authentication and authorization protocol used on many networks, as implemented by Microsoft's Active Directory (AD) service. Kerberos was named after the three-headed guard dog of Hades (Cerberus) because it consists of three parts. Clients request services from application servers, which rely on an intermediary—a key distribution center (KDC) —to vouch for their identity. Two services comprise a KDC: the Authentication Service and the Ticket Granting Service. Kerberos can authenticate human users and application services. These are collectively referred to as principals. Using authentication to a Windows domain as an example, the first step in Kerberos SSO is to authenticate with a KDC server implemented as a domain controller. The principal sends the authentication service (AS) a request for a Ticket Granting Ticket (TGT). This is composed by encrypting the date and time on the local computer with the user's password hash as the key. The password hash itself is not transmitted over the network. Although we refer to passwords for simplicity, the system can use other authenticators, such as smart card login. The AS checks that the user account is present, that it can decode the request by matching the user's password hash with the one in the Active Directory database, and that the request has not expired. If the request is valid, the AS responds with the following data: Ticket Granting Ticket (TGT) — contains information about the client (name and IP address) plus a time stamp and validity period. This is encrypted using the KDC's secret key. TGS session key — communicates between the client and the Ticket Granting Service (TGS). This is encrypted using a hash of the user's password. The TGT is an example of a logical token. All the TGT does is identify who you are and confirm that you have been authenticated—it does not provide you with access to any domain resources. Single Sign-on Authorization Presuming the user entered the correct password, the client can decrypt the Ticket Granting Service (TGS) session key but not the TGT. This establishes that the client and KDC know the same shared secret and that the client cannot interfere with the TGT. The principal requests a service ticket to access resources within the domain (a token that grants access to a target application server). This process of granting service tickets is handled by the TGS. The principal sends the TGS a copy of its TGT, the name of the application server it wishes to access, and an authenticator consisting of a time-stamped client ID encrypted using the TGS session key. The TGS should be able to decrypt both messages using the KDC's secret key for the first and the TGS session key for the second. This confirms that the request is genuine. It also checks that the ticket has not expired and has not been used before (replay attack). A Service session key — is used between the client and the application server. This is encrypted with the TGS session key. A Service ticket — contains information about the principal, such as a time stamp, system IP address, Security Identifier (SID), the SIDs of groups to which it belongs, and the service session key. This is encrypted using the application server's secret key. The principal forwards the service ticket, which it cannot decrypt, to the application server and adds another time-stamped authenticator, which is encrypted using the service session key. The application server decrypts the service ticket to obtain the service session key using its secret key, confirming that the principal has sent it an untampered message. It then decrypts the authenticator using the service session key. Optionally, the application server responds to the principal with the time stamp used in the authenticator, which is encrypted using the service session key. The principal decrypts the time stamp, verifies that it matches the value already sent, and concludes that the application server is trustworthy. This means the server is authenticated to the principal (mutual authentication). This prevents an on-path attack, where a malicious user could intercept communications between the principal and server. The server now responds to access requests (assuming they conform to the server's access control list). Federation Federation is the notion that a network needs to be accessible to more than just a well-defined group of employees. A company might need to open parts of its network to partners, suppliers, and customers. The company can manage its employee accounts easily enough. Managing accounts for each supplier or customer internally may be more difficult. Federation means the company trusts accounts created and managed by a different network. As another example, in the consumer world, a user might want to use both Google Workspace and Twitter. Suppose Google and Twitter establish a federated network for authentication and authorization. In that case, users can log on to Twitter using their Google credentials or vice versa. An on-premises network can use technologies such as LDAP and Kerberos, very often implemented as a Windows Active Directory network, because the administration of accounts and devices can be centralized. When implementing Federation, authentication and authorization design comes with more constraints and additional requirements to ensure interoperability between different platforms. Web applications might not support Kerberos, while third-party networks might not support direct Federation with Active Directory/LDAP. The design for these cloud networks likely requires using other standard protocols or frameworks for interoperability between web applications. These interoperable federation protocols use claims-based identity. While the technical implementation and terminology are different, the overall model is similar to that of Kerberos SSO: The principal attempts to access a service provider (SP). The service provider redirects the principal to an identity provider (IdP) to authenticate. The principal authenticates with the identity provider and obtains a claim in the form of a token or document signed by the IdP. The principal presents the claim to the service provider. The SP can validate that the IdP has signed the claim because of its trust relationship with the IdP. The service provider can now connect the authenticated principal to its accounts database to determine its permissions and other attributes. It may be able to query attributes of the user account profile held by the IdP if the principal has authorized this type of access. A federated network or cloud needs specific protocols and technologies to implement user identity assertions and transmit claims between the principal, the relying party, and the identity provider. Security Assertion Markup Language (SAML) is one such solution. SAML assertions (claims) are written in eXtensible Markup Language (XML). Communications are established using HTTP/HTTPS and the Simple Object Access Protocol (SOAP). The secure tokens are signed using the XML signature specification. Using a digital signature allows the relying party to trust the identity provider. Open Authorization Many public clouds use application programming interfaces (APIs) based on Representational State Transfer (REST) rather than SOAP. These are called RESTful APIs. Where SOAP is a tightly specified protocol, REST is a looser architectural framework. This allows the service provider more choice over implementation elements. Compared to SOAP and SAML, there is better support for mobile apps. Authentication and authorization for a RESTful API are often implemented using the Open Authorization (OAuth) protocol. OAuth is designed to facilitate the sharing of information (resources) within a user profile between sites. The user creates a password-protected account at an identity provider (IdP). The user can link that identity to an OAuth consumer site without giving the password to the consumer site. A user (resource owner) can grant an OAuth client authorization to access some part of their account. A client in this context is an app or consumer site. The user account is hosted by one or more resource servers. A resource server is called an API server because it hosts the functions that allow OAuth clients (consumer sites and mobile apps) to access user attributes. An authorization server processes authorization requests. A single authorization server can manage multiple resource servers; equally, the resource and authorization server could be the same server instance. The client app or service must be registered with the authorization server. As part of this process, the client registers a redirect URL, which is the endpoint that will process authorization tokens. Registration also provides the client with an ID and a secret. The ID can be publicly exposed, but the client and the authorization server must keep the secret confidential. When the client application requests authorization, the user approves the authorization server to grant the request using an appropriate method. OAuth supports several grant types—or flows—for use in different contexts, such as server to server or mobile app to server. Depending on the flow type, the client will end up with an access token validated by the authorization server. The client presents the access token to the resource server, which then accepts the request for the resource if the token is valid.",
  "chunks": [
    {
      "chunk_id": "4.9.2_chunk_1",
      "content": "Security Pro 8.0",
      "summary": "Security Pro 8.0",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.9.2",
        "title": "Network Authentication Facts",
        "content_type": "text",
        "filename": "4.9.2_Network_Authentication_Facts_[text].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.9.2_Network_Authentication_Facts_[text].txt",
        "word_count": 1724,
        "has_content": true
      },
      "section_header": "Introduction",
      "timestamp_range": null
    },
    {
      "chunk_id": "4.9.2_chunk_2",
      "content": "This lesson covers the following topics: Network authentication overview Single sign-on authentication Single sign-on authorization Federation Open authorization Network Authentication Overview Authentication is the process of validating user credentials that prove user identity. Authentication is typically the first step in connecting to a network. Following successful authentication, access controls can be implemented to allow or deny access to network resources. A simple form of authentication sends a username and password to an authentication server. If the password is sent in cleartext, the authentication credentials can be intercepted and used to impersonate an authorized user. One method of protecting login credentials is using a challenge/response mechanism (also called a three-way handshake). By doing so, both the authentication server and the authenticator are configured with a common shared secret. This shared secret is usually a password associated with a user account. The process is: The authentication server sends a challenge string to the authenticator. The authenticator uses the shared secret to hash the challenge string and returns the user account name and the hashed value to the authentication server. The authentication server also uses its shared secret value to hash the challenge string. If the two hashed values match, the authentication server assumes the authenticator knows the shared secret. Single Sign-on Authentication A single sign-on (SSO) system allows users to authenticate once and then receive authorizations on compatible application servers without entering credentials again. Kerberos is a single sign-on network authentication and authorization protocol used on many networks, as implemented by Microsoft's Active Directory (AD) service. Kerberos was named after the three-headed guard dog of Hades (Cerberus) because it consists of three parts. Clients request services from application servers, which rely on an intermediary—a key distribution center (KDC) —to vouch for their identity. Two services comprise a KDC: the Authentication Service and the Ticket Granting Service. Kerberos can authenticate human users and application services. These are collectively referred to as principals. Using authentication to a Windows domain as an example, the first step in Kerberos SSO is to authenticate with a KDC server implemented as a domain controller. The principal sends the authentication service (AS) a request for a Ticket Granting Ticket (TGT). This is composed by encrypting the date and time on the local computer with the user's password hash as the key. The password hash itself is not transmitted over the network. Although we refer to passwords for simplicity, the system can use other authenticators, such as smart card login. The AS checks that the user account is present, that it can decode the request by matching the user's password hash with the one in the Active Directory database, and that the request has not expired. If the request is valid, the AS responds with the following data: Ticket Granting Ticket (TGT) — contains information about the client (name and IP address) plus a time stamp and validity period. This is encrypted using the KDC's secret key. TGS session key — communicates between the client and the Ticket Granting Service (TGS). This is encrypted using a hash of the user's password. The TGT is an example of a logical token. All the TGT does is identify who you are and confirm that you have been authenticated—it does not provide you with access to any domain resources. Single Sign-on Authorization Presuming the user entered the correct password, the client can decrypt the Ticket Granting Service (TGS) session key but not the TGT. This establishes that the client and KDC know the same shared secret and that the client cannot interfere with the TGT. The principal requests a service ticket to access resources within the domain (a token that grants access to a target application server). This process of granting service tickets is handled by the TGS. The principal sends the TGS a copy of its TGT, the name of the application server it wishes to access, and an authenticator consisting of a time-stamped client ID encrypted using the TGS session key. The TGS should be able to decrypt both messages using the KDC's secret key for the first and the TGS session key for the second. This confirms that the request is genuine. It also checks that the ticket has not expired and has not been used before (replay attack).",
      "summary": "4.9.2 Network Authentication Facts: This lesson covers the following topics: Network authentication overview Single sign-on authentication Single sign-on authorization Federation Open authorization Network Authentication Overview Authentication is the process of validating user credentials that prove user identity. Following successful authentication, access controls can be implemented to allow or deny access to network resources.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.9.2",
        "title": "Network Authentication Facts",
        "content_type": "text",
        "filename": "4.9.2_Network_Authentication_Facts_[text].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.9.2_Network_Authentication_Facts_[text].txt",
        "word_count": 1724,
        "has_content": true
      },
      "section_header": "4.9.2 Network Authentication Facts",
      "timestamp_range": null
    },
    {
      "chunk_id": "4.9.2_chunk_3",
      "content": "A Service session key — is used between the client and the application server. This is encrypted with the TGS session key. A Service ticket — contains information about the principal, such as a time stamp, system IP address, Security Identifier (SID), the SIDs of groups to which it belongs, and the service session key. This is encrypted using the application server's secret key. The principal forwards the service ticket, which it cannot decrypt, to the application server and adds another time-stamped authenticator, which is encrypted using the service session key. The application server decrypts the service ticket to obtain the service session key using its secret key, confirming that the principal has sent it an untampered message. It then decrypts the authenticator using the service session key. Optionally, the application server responds to the principal with the time stamp used in the authenticator, which is encrypted using the service session key. The principal decrypts the time stamp, verifies that it matches the value already sent, and concludes that the application server is trustworthy. This means the server is authenticated to the principal (mutual authentication). This prevents an on-path attack, where a malicious user could intercept communications between the principal and server. The server now responds to access requests (assuming they conform to the server's access control list). Federation Federation is the notion that a network needs to be accessible to more than just a well-defined group of employees. A company might need to open parts of its network to partners, suppliers, and customers. The company can manage its employee accounts easily enough. Managing accounts for each supplier or customer internally may be more difficult. Federation means the company trusts accounts created and managed by a different network. As another example, in the consumer world, a user might want to use both Google Workspace and Twitter. Suppose Google and Twitter establish a federated network for authentication and authorization. In that case, users can log on to Twitter using their Google credentials or vice versa. An on-premises network can use technologies such as LDAP and Kerberos, very often implemented as a Windows Active Directory network, because the administration of accounts and devices can be centralized. When implementing Federation, authentication and authorization design comes with more constraints and additional requirements to ensure interoperability between different platforms. Web applications might not support Kerberos, while third-party networks might not support direct Federation with Active Directory/LDAP. The design for these cloud networks likely requires using other standard protocols or frameworks for interoperability between web applications. These interoperable federation protocols use claims-based identity. While the technical implementation and terminology are different, the overall model is similar to that of Kerberos SSO: The principal attempts to access a service provider (SP). The service provider redirects the principal to an identity provider (IdP) to authenticate. The principal authenticates with the identity provider and obtains a claim in the form of a token or document signed by the IdP. The principal presents the claim to the service provider. The SP can validate that the IdP has signed the claim because of its trust relationship with the IdP. The service provider can now connect the authenticated principal to its accounts database to determine its permissions and other attributes. It may be able to query attributes of the user account profile held by the IdP if the principal has authorized this type of access. A federated network or cloud needs specific protocols and technologies to implement user identity assertions and transmit claims between the principal, the relying party, and the identity provider. Security Assertion Markup Language (SAML) is one such solution. SAML assertions (claims) are written in eXtensible Markup Language (XML). Communications are established using HTTP/HTTPS and the Simple Object Access Protocol (SOAP). The secure tokens are signed using the XML signature specification. Using a digital signature allows the relying party to trust the identity provider. Open Authorization Many public clouds use application programming interfaces (APIs) based on Representational State Transfer (REST) rather than SOAP. These are called RESTful APIs. Where SOAP is a tightly specified protocol, REST is a looser architectural framework. This allows the service provider more choice over implementation elements. Compared to SOAP and SAML, there is better support for mobile apps. Authentication and authorization for a RESTful API are often implemented using the Open Authorization (OAuth) protocol. OAuth is designed to facilitate the sharing of information (resources) within a user profile between sites. The user creates a password-protected account at an identity provider (IdP). The user can link that identity to an OAuth consumer site without giving the password to the consumer site. A user (resource owner) can grant an OAuth client authorization to access some part of their account. A client in this context is an app or consumer site. The user account is hosted by one or more resource servers. A resource server is called an API server because it hosts the functions that allow OAuth clients (consumer sites and mobile apps) to access user attributes. An authorization server processes authorization requests. A single authorization server can manage multiple resource servers; equally, the resource and authorization server could be the same server instance. The client app or service must be registered with the authorization server. As part of this process, the client registers a redirect URL, which is the endpoint that will process authorization tokens. Registration also provides the client with an ID and a secret. The ID can be publicly exposed, but the client and the authorization server must keep the secret confidential. When the client application requests authorization, the user approves the authorization server to grant the request using an appropriate method. OAuth supports several grant types—or flows—for use in different contexts, such as server to server or mobile app to server. Depending on the flow type, the client will end up with an access token validated by the authorization server. The client presents the access token to the resource server, which then accepts the request for the resource if the token is valid.",
      "summary": "The TGS service responds with the following:: The server now responds to access requests (assuming they conform to the server's access control list). Suppose Google and Twitter establish a federated network for authentication and authorization.",
      "metadata": {
        "chapter_num": "4",
        "section_num": "4.9.2",
        "title": "Network Authentication Facts",
        "content_type": "text",
        "filename": "4.9.2_Network_Authentication_Facts_[text].txt",
        "file_path": "/Users/basantabaral/CompTia/data_raw/04_Identity_and_Access_Management/4.9.2_Network_Authentication_Facts_[text].txt",
        "word_count": 1724,
        "has_content": true
      },
      "section_header": "The TGS service responds with the following:",
      "timestamp_range": null
    }
  ],
  "num_chunks": 3,
  "document_summary": "Network Authentication Facts (text): 0 This lesson covers the following topics: Network authentication overview Single sign-on authentication Single sign-on authorization Federation Open authorization Network Authentication Overview Authentication is the process of validating user credentials that prove user identity. Following successful authentication, access controls can be implemented to allow or deny access to network resources. Kerberos is a single sign-on network authentication and authorization protocol used on many networks, as implemented by Microsoft's Active Directory (AD) service."
}